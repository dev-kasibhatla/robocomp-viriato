//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.3
//
// <auto-generated>
//
// Generated from file `InnerModelManager.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __InnerModelManager_h__
#define __InnerModelManager_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/ValueF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Comparable.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/GCObject.h>
#include <Ice/Value.h>
#include <Ice/Incoming.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <Ice/Optional.h>
#include <Ice/ExceptionHelpers.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 >= 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 3
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace RoboCompInnerModelManager
{

class InnerModelManager;
class InnerModelManagerPrx;

}

namespace RoboCompInnerModelManager
{

enum class NodeType : unsigned char
{
    Transform,
    Joint,
    DifferentialRobot,
    OmniRobot,
    Plane,
    Camera,
    RGBD,
    IMU,
    Laser,
    Mesh,
    PointCloud,
    TouchSensor,
    DisplayII
};

struct AttributeType
{
    ::std::string type;
    ::std::string value;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::string&> ice_tuple() const
    {
        return std::tie(type, value);
    }
};

using AttributeMap = ::std::map<::std::string, AttributeType>;

struct NodeInformation
{
    ::std::string id;
    ::std::string parentId;
    ::RoboCompInnerModelManager::NodeType nType;
    ::RoboCompInnerModelManager::AttributeMap attributes;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::string&, const ::RoboCompInnerModelManager::NodeType&, const ::RoboCompInnerModelManager::AttributeMap&> ice_tuple() const
    {
        return std::tie(id, parentId, nType, attributes);
    }
};

using NodeInformationSequence = ::std::vector<NodeInformation>;

enum class ErrorType : unsigned char
{
    NonExistingNode,
    NonExistingAttribute,
    NodeAlreadyExists,
    AttributeAlreadyExists,
    InvalidPath,
    InvalidEngine,
    InvalidValues,
    OperationInvalidNode,
    InternalError,
    Collision
};

class InnerModelManagerError : public ::Ice::UserExceptionHelper<InnerModelManagerError, ::Ice::UserException>
{
public:

    virtual ~InnerModelManagerError();

    InnerModelManagerError(const InnerModelManagerError&) = default;

    InnerModelManagerError() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    InnerModelManagerError(ErrorType err, const ::std::string& text) :
        err(err),
        text(::std::move(text))
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::RoboCompInnerModelManager::ErrorType&, const ::std::string&> ice_tuple() const
    {
        return std::tie(err, text);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::RoboCompInnerModelManager::ErrorType err;
    ::std::string text;
};

/// \cond INTERNAL
static InnerModelManagerError _iceS_InnerModelManagerError_init;
/// \endcond

struct Colored3DPoint
{
    float x;
    float y;
    float z;
    ::Ice::Byte r;
    ::Ice::Byte g;
    ::Ice::Byte b;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const float&, const float&, const float&, const ::Ice::Byte&, const ::Ice::Byte&, const ::Ice::Byte&> ice_tuple() const
    {
        return std::tie(x, y, z, r, g, b);
    }
};

using PointCloudVector = ::std::vector<Colored3DPoint>;

struct Plane3D
{
    float px;
    float py;
    float pz;
    float nx;
    float ny;
    float nz;
    float width;
    float height;
    float thickness;
    ::std::string texture;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const float&, const float&, const float&, const float&, const float&, const float&, const float&, const float&, const float&, const ::std::string&> ice_tuple() const
    {
        return std::tie(px, py, pz, nx, ny, nz, width, height, thickness, texture);
    }
};

struct coord3D
{
    float x;
    float y;
    float z;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const float&, const float&, const float&> ice_tuple() const
    {
        return std::tie(x, y, z);
    }
};

struct Pose3D
{
    float x;
    float y;
    float z;
    float rx;
    float ry;
    float rz;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const float&, const float&, const float&, const float&, const float&, const float&> ice_tuple() const
    {
        return std::tie(x, y, z, rx, ry, rz);
    }
};

struct jointType
{
    ::RoboCompInnerModelManager::Pose3D pose;
    float lx;
    float ly;
    float lz;
    float hx;
    float hy;
    float hz;
    float mass;
    float min;
    float max;
    ::std::string axis;
    int port;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::RoboCompInnerModelManager::Pose3D&, const float&, const float&, const float&, const float&, const float&, const float&, const float&, const float&, const float&, const ::std::string&, const int&> ice_tuple() const
    {
        return std::tie(pose, lx, ly, lz, hx, hy, hz, mass, min, max, axis, port);
    }
};

struct meshType
{
    ::RoboCompInnerModelManager::Pose3D pose;
    float scaleX;
    float scaleY;
    float scaleZ;
    int render;
    ::std::string meshPath;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::RoboCompInnerModelManager::Pose3D&, const float&, const float&, const float&, const int&, const ::std::string&> ice_tuple() const
    {
        return std::tie(pose, scaleX, scaleY, scaleZ, render, meshPath);
    }
};

using FloatSeq = ::std::vector<float>;

struct Matrix
{
    int cols;
    int rows;
    ::RoboCompInnerModelManager::FloatSeq data;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const int&, const ::RoboCompInnerModelManager::FloatSeq&> ice_tuple() const
    {
        return std::tie(cols, rows, data);
    }
};

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

namespace RoboCompInnerModelManager
{

class InnerModelManager : public virtual ::Ice::Object
{
public:

    using ProxyType = InnerModelManagerPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual bool addAttribute(::std::string idNode, ::std::string name, ::std::string type, ::std::string value, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_addAttribute(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool addJoint(::std::string item, ::std::string base, jointType j, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_addJoint(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool addMesh(::std::string item, ::std::string base, meshType m, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_addMesh(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool addPlane(::std::string item, ::std::string base, Plane3D plane, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_addPlane(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool addTransform(::std::string item, ::std::string engine, ::std::string base, Pose3D pose, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_addTransform(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool collide(::std::string a, ::std::string b, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_collide(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void getAllNodeInformation(NodeInformationSequence& nodesInfo, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getAllNodeInformation(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to getAttribute.
     */
    struct GetAttributeResult
    {
        bool returnValue;
        ::std::string type;
        ::std::string value;
    };

    virtual bool getAttribute(::std::string idNode, ::std::string name, ::std::string& type, ::std::string& value, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getAttribute(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to getPose.
     */
    struct GetPoseResult
    {
        bool returnValue;
        Pose3D pose;
    };

    virtual bool getPose(::std::string base, ::std::string item, Pose3D& pose, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getPose(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to getPoseFromParent.
     */
    struct GetPoseFromParentResult
    {
        bool returnValue;
        Pose3D pose;
    };

    virtual bool getPoseFromParent(::std::string item, Pose3D& pose, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getPoseFromParent(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual Matrix getTransformationMatrix(::std::string base, ::std::string item, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getTransformationMatrix(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool moveNode(::std::string src, ::std::string dst, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_moveNode(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool removeAttribute(::std::string idNode, ::std::string name, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_removeAttribute(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool removeNode(::std::string item, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_removeNode(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool setAttribute(::std::string idNode, ::std::string name, ::std::string type, ::std::string value, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setAttribute(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool setPlane(::std::string item, Plane3D plane, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setPlane(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void setPointCloudData(::std::string id, PointCloudVector cloud, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setPointCloudData(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool setPose(::std::string base, ::std::string item, Pose3D pose, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setPose(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool setPoseFromParent(::std::string item, Pose3D pose, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setPoseFromParent(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool setScale(::std::string item, float scaleX, float scaleY, float scaleZ, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setScale(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to transform.
     */
    struct TransformResult
    {
        bool returnValue;
        coord3D coordInBase;
    };

    virtual bool transform(::std::string base, ::std::string item, coord3D coordInItem, coord3D& coordInBase, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_transform(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

}

namespace RoboCompInnerModelManager
{

class InnerModelManagerPrx : public virtual ::Ice::Proxy<InnerModelManagerPrx, ::Ice::ObjectPrx>
{
public:

    bool addAttribute(const ::std::string& idNode, const ::std::string& name, const ::std::string& type, const ::std::string& value, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &InnerModelManagerPrx::_iceI_addAttribute, idNode, name, type, value, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto addAttributeAsync(const ::std::string& idNode, const ::std::string& name, const ::std::string& type, const ::std::string& value, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &InnerModelManagerPrx::_iceI_addAttribute, idNode, name, type, value, context);
    }

    ::std::function<void()>
    addAttributeAsync(const ::std::string& idNode, const ::std::string& name, const ::std::string& type, const ::std::string& value,
                      ::std::function<void(bool)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(response, ex, sent, this, &RoboCompInnerModelManager::InnerModelManagerPrx::_iceI_addAttribute, idNode, name, type, value, context);
    }

    /// \cond INTERNAL
    void _iceI_addAttribute(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    bool addJoint(const ::std::string& item, const ::std::string& base, const jointType& j, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &InnerModelManagerPrx::_iceI_addJoint, item, base, j, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto addJointAsync(const ::std::string& item, const ::std::string& base, const jointType& j, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &InnerModelManagerPrx::_iceI_addJoint, item, base, j, context);
    }

    ::std::function<void()>
    addJointAsync(const ::std::string& item, const ::std::string& base, const jointType& j,
                  ::std::function<void(bool)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(response, ex, sent, this, &RoboCompInnerModelManager::InnerModelManagerPrx::_iceI_addJoint, item, base, j, context);
    }

    /// \cond INTERNAL
    void _iceI_addJoint(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::std::string&, const ::std::string&, const jointType&, const ::Ice::Context&);
    /// \endcond

    bool addMesh(const ::std::string& item, const ::std::string& base, const meshType& m, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &InnerModelManagerPrx::_iceI_addMesh, item, base, m, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto addMeshAsync(const ::std::string& item, const ::std::string& base, const meshType& m, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &InnerModelManagerPrx::_iceI_addMesh, item, base, m, context);
    }

    ::std::function<void()>
    addMeshAsync(const ::std::string& item, const ::std::string& base, const meshType& m,
                 ::std::function<void(bool)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(response, ex, sent, this, &RoboCompInnerModelManager::InnerModelManagerPrx::_iceI_addMesh, item, base, m, context);
    }

    /// \cond INTERNAL
    void _iceI_addMesh(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::std::string&, const ::std::string&, const meshType&, const ::Ice::Context&);
    /// \endcond

    bool addPlane(const ::std::string& item, const ::std::string& base, const Plane3D& plane, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &InnerModelManagerPrx::_iceI_addPlane, item, base, plane, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto addPlaneAsync(const ::std::string& item, const ::std::string& base, const Plane3D& plane, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &InnerModelManagerPrx::_iceI_addPlane, item, base, plane, context);
    }

    ::std::function<void()>
    addPlaneAsync(const ::std::string& item, const ::std::string& base, const Plane3D& plane,
                  ::std::function<void(bool)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(response, ex, sent, this, &RoboCompInnerModelManager::InnerModelManagerPrx::_iceI_addPlane, item, base, plane, context);
    }

    /// \cond INTERNAL
    void _iceI_addPlane(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::std::string&, const ::std::string&, const Plane3D&, const ::Ice::Context&);
    /// \endcond

    bool addTransform(const ::std::string& item, const ::std::string& engine, const ::std::string& base, const Pose3D& pose, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &InnerModelManagerPrx::_iceI_addTransform, item, engine, base, pose, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto addTransformAsync(const ::std::string& item, const ::std::string& engine, const ::std::string& base, const Pose3D& pose, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &InnerModelManagerPrx::_iceI_addTransform, item, engine, base, pose, context);
    }

    ::std::function<void()>
    addTransformAsync(const ::std::string& item, const ::std::string& engine, const ::std::string& base, const Pose3D& pose,
                      ::std::function<void(bool)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(response, ex, sent, this, &RoboCompInnerModelManager::InnerModelManagerPrx::_iceI_addTransform, item, engine, base, pose, context);
    }

    /// \cond INTERNAL
    void _iceI_addTransform(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::std::string&, const ::std::string&, const ::std::string&, const Pose3D&, const ::Ice::Context&);
    /// \endcond

    bool collide(const ::std::string& a, const ::std::string& b, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &InnerModelManagerPrx::_iceI_collide, a, b, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto collideAsync(const ::std::string& a, const ::std::string& b, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &InnerModelManagerPrx::_iceI_collide, a, b, context);
    }

    ::std::function<void()>
    collideAsync(const ::std::string& a, const ::std::string& b,
                 ::std::function<void(bool)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(response, ex, sent, this, &RoboCompInnerModelManager::InnerModelManagerPrx::_iceI_collide, a, b, context);
    }

    /// \cond INTERNAL
    void _iceI_collide(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    void getAllNodeInformation(NodeInformationSequence& nodesInfo, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        nodesInfo = _makePromiseOutgoing<::RoboCompInnerModelManager::NodeInformationSequence>(true, this, &InnerModelManagerPrx::_iceI_getAllNodeInformation, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getAllNodeInformationAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::RoboCompInnerModelManager::NodeInformationSequence>>().get_future())
    {
        return _makePromiseOutgoing<::RoboCompInnerModelManager::NodeInformationSequence, P>(false, this, &InnerModelManagerPrx::_iceI_getAllNodeInformation, context);
    }

    ::std::function<void()>
    getAllNodeInformationAsync(::std::function<void(::RoboCompInnerModelManager::NodeInformationSequence)> response,
                               ::std::function<void(::std::exception_ptr)> ex = nullptr,
                               ::std::function<void(bool)> sent = nullptr,
                               const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::RoboCompInnerModelManager::NodeInformationSequence>(response, ex, sent, this, &RoboCompInnerModelManager::InnerModelManagerPrx::_iceI_getAllNodeInformation, context);
    }

    /// \cond INTERNAL
    void _iceI_getAllNodeInformation(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::RoboCompInnerModelManager::NodeInformationSequence>>&, const ::Ice::Context&);
    /// \endcond

    bool getAttribute(const ::std::string& idNode, const ::std::string& name, ::std::string& type, ::std::string& value, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<InnerModelManager::GetAttributeResult>(true, this, &InnerModelManagerPrx::_iceI_getAttribute, idNode, name, context).get();
        type = ::std::move(_result.type);
        value = ::std::move(_result.value);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto getAttributeAsync(const ::std::string& idNode, const ::std::string& name, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<InnerModelManager::GetAttributeResult>>().get_future())
    {
        return _makePromiseOutgoing<InnerModelManager::GetAttributeResult, P>(false, this, &InnerModelManagerPrx::_iceI_getAttribute, idNode, name, context);
    }

    ::std::function<void()>
    getAttributeAsync(const ::std::string& idNode, const ::std::string& name,
                      ::std::function<void(bool, ::std::string, ::std::string)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](InnerModelManager::GetAttributeResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.type), ::std::move(_result.value));
        };
        return _makeLamdaOutgoing<InnerModelManager::GetAttributeResult>(_responseCb, ex, sent, this, &RoboCompInnerModelManager::InnerModelManagerPrx::_iceI_getAttribute, idNode, name, context);
    }

    /// \cond INTERNAL
    void _iceI_getAttribute(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<InnerModelManager::GetAttributeResult>>&, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    bool getPose(const ::std::string& base, const ::std::string& item, Pose3D& pose, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<InnerModelManager::GetPoseResult>(true, this, &InnerModelManagerPrx::_iceI_getPose, base, item, context).get();
        pose = ::std::move(_result.pose);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto getPoseAsync(const ::std::string& base, const ::std::string& item, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<InnerModelManager::GetPoseResult>>().get_future())
    {
        return _makePromiseOutgoing<InnerModelManager::GetPoseResult, P>(false, this, &InnerModelManagerPrx::_iceI_getPose, base, item, context);
    }

    ::std::function<void()>
    getPoseAsync(const ::std::string& base, const ::std::string& item,
                 ::std::function<void(bool, ::RoboCompInnerModelManager::Pose3D)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](InnerModelManager::GetPoseResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.pose));
        };
        return _makeLamdaOutgoing<InnerModelManager::GetPoseResult>(_responseCb, ex, sent, this, &RoboCompInnerModelManager::InnerModelManagerPrx::_iceI_getPose, base, item, context);
    }

    /// \cond INTERNAL
    void _iceI_getPose(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<InnerModelManager::GetPoseResult>>&, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    bool getPoseFromParent(const ::std::string& item, Pose3D& pose, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<InnerModelManager::GetPoseFromParentResult>(true, this, &InnerModelManagerPrx::_iceI_getPoseFromParent, item, context).get();
        pose = ::std::move(_result.pose);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto getPoseFromParentAsync(const ::std::string& item, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<InnerModelManager::GetPoseFromParentResult>>().get_future())
    {
        return _makePromiseOutgoing<InnerModelManager::GetPoseFromParentResult, P>(false, this, &InnerModelManagerPrx::_iceI_getPoseFromParent, item, context);
    }

    ::std::function<void()>
    getPoseFromParentAsync(const ::std::string& item,
                           ::std::function<void(bool, ::RoboCompInnerModelManager::Pose3D)> response,
                           ::std::function<void(::std::exception_ptr)> ex = nullptr,
                           ::std::function<void(bool)> sent = nullptr,
                           const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](InnerModelManager::GetPoseFromParentResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.pose));
        };
        return _makeLamdaOutgoing<InnerModelManager::GetPoseFromParentResult>(_responseCb, ex, sent, this, &RoboCompInnerModelManager::InnerModelManagerPrx::_iceI_getPoseFromParent, item, context);
    }

    /// \cond INTERNAL
    void _iceI_getPoseFromParent(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<InnerModelManager::GetPoseFromParentResult>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    Matrix getTransformationMatrix(const ::std::string& base, const ::std::string& item, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::RoboCompInnerModelManager::Matrix>(true, this, &InnerModelManagerPrx::_iceI_getTransformationMatrix, base, item, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getTransformationMatrixAsync(const ::std::string& base, const ::std::string& item, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::RoboCompInnerModelManager::Matrix>>().get_future())
    {
        return _makePromiseOutgoing<::RoboCompInnerModelManager::Matrix, P>(false, this, &InnerModelManagerPrx::_iceI_getTransformationMatrix, base, item, context);
    }

    ::std::function<void()>
    getTransformationMatrixAsync(const ::std::string& base, const ::std::string& item,
                                 ::std::function<void(::RoboCompInnerModelManager::Matrix)> response,
                                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                 ::std::function<void(bool)> sent = nullptr,
                                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::RoboCompInnerModelManager::Matrix>(response, ex, sent, this, &RoboCompInnerModelManager::InnerModelManagerPrx::_iceI_getTransformationMatrix, base, item, context);
    }

    /// \cond INTERNAL
    void _iceI_getTransformationMatrix(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::RoboCompInnerModelManager::Matrix>>&, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    bool moveNode(const ::std::string& src, const ::std::string& dst, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &InnerModelManagerPrx::_iceI_moveNode, src, dst, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto moveNodeAsync(const ::std::string& src, const ::std::string& dst, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &InnerModelManagerPrx::_iceI_moveNode, src, dst, context);
    }

    ::std::function<void()>
    moveNodeAsync(const ::std::string& src, const ::std::string& dst,
                  ::std::function<void(bool)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(response, ex, sent, this, &RoboCompInnerModelManager::InnerModelManagerPrx::_iceI_moveNode, src, dst, context);
    }

    /// \cond INTERNAL
    void _iceI_moveNode(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    bool removeAttribute(const ::std::string& idNode, const ::std::string& name, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &InnerModelManagerPrx::_iceI_removeAttribute, idNode, name, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto removeAttributeAsync(const ::std::string& idNode, const ::std::string& name, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &InnerModelManagerPrx::_iceI_removeAttribute, idNode, name, context);
    }

    ::std::function<void()>
    removeAttributeAsync(const ::std::string& idNode, const ::std::string& name,
                         ::std::function<void(bool)> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(response, ex, sent, this, &RoboCompInnerModelManager::InnerModelManagerPrx::_iceI_removeAttribute, idNode, name, context);
    }

    /// \cond INTERNAL
    void _iceI_removeAttribute(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    bool removeNode(const ::std::string& item, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &InnerModelManagerPrx::_iceI_removeNode, item, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto removeNodeAsync(const ::std::string& item, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &InnerModelManagerPrx::_iceI_removeNode, item, context);
    }

    ::std::function<void()>
    removeNodeAsync(const ::std::string& item,
                    ::std::function<void(bool)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(response, ex, sent, this, &RoboCompInnerModelManager::InnerModelManagerPrx::_iceI_removeNode, item, context);
    }

    /// \cond INTERNAL
    void _iceI_removeNode(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    bool setAttribute(const ::std::string& idNode, const ::std::string& name, const ::std::string& type, const ::std::string& value, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &InnerModelManagerPrx::_iceI_setAttribute, idNode, name, type, value, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto setAttributeAsync(const ::std::string& idNode, const ::std::string& name, const ::std::string& type, const ::std::string& value, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &InnerModelManagerPrx::_iceI_setAttribute, idNode, name, type, value, context);
    }

    ::std::function<void()>
    setAttributeAsync(const ::std::string& idNode, const ::std::string& name, const ::std::string& type, const ::std::string& value,
                      ::std::function<void(bool)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(response, ex, sent, this, &RoboCompInnerModelManager::InnerModelManagerPrx::_iceI_setAttribute, idNode, name, type, value, context);
    }

    /// \cond INTERNAL
    void _iceI_setAttribute(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    bool setPlane(const ::std::string& item, const Plane3D& plane, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &InnerModelManagerPrx::_iceI_setPlane, item, plane, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto setPlaneAsync(const ::std::string& item, const Plane3D& plane, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &InnerModelManagerPrx::_iceI_setPlane, item, plane, context);
    }

    ::std::function<void()>
    setPlaneAsync(const ::std::string& item, const Plane3D& plane,
                  ::std::function<void(bool)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(response, ex, sent, this, &RoboCompInnerModelManager::InnerModelManagerPrx::_iceI_setPlane, item, plane, context);
    }

    /// \cond INTERNAL
    void _iceI_setPlane(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::std::string&, const Plane3D&, const ::Ice::Context&);
    /// \endcond

    void setPointCloudData(const ::std::string& id, const PointCloudVector& cloud, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &InnerModelManagerPrx::_iceI_setPointCloudData, id, cloud, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto setPointCloudDataAsync(const ::std::string& id, const PointCloudVector& cloud, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &InnerModelManagerPrx::_iceI_setPointCloudData, id, cloud, context);
    }

    ::std::function<void()>
    setPointCloudDataAsync(const ::std::string& id, const PointCloudVector& cloud,
                           ::std::function<void()> response,
                           ::std::function<void(::std::exception_ptr)> ex = nullptr,
                           ::std::function<void(bool)> sent = nullptr,
                           const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(response, ex, sent, this, &RoboCompInnerModelManager::InnerModelManagerPrx::_iceI_setPointCloudData, id, cloud, context);
    }

    /// \cond INTERNAL
    void _iceI_setPointCloudData(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, const PointCloudVector&, const ::Ice::Context&);
    /// \endcond

    bool setPose(const ::std::string& base, const ::std::string& item, const Pose3D& pose, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &InnerModelManagerPrx::_iceI_setPose, base, item, pose, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto setPoseAsync(const ::std::string& base, const ::std::string& item, const Pose3D& pose, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &InnerModelManagerPrx::_iceI_setPose, base, item, pose, context);
    }

    ::std::function<void()>
    setPoseAsync(const ::std::string& base, const ::std::string& item, const Pose3D& pose,
                 ::std::function<void(bool)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(response, ex, sent, this, &RoboCompInnerModelManager::InnerModelManagerPrx::_iceI_setPose, base, item, pose, context);
    }

    /// \cond INTERNAL
    void _iceI_setPose(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::std::string&, const ::std::string&, const Pose3D&, const ::Ice::Context&);
    /// \endcond

    bool setPoseFromParent(const ::std::string& item, const Pose3D& pose, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &InnerModelManagerPrx::_iceI_setPoseFromParent, item, pose, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto setPoseFromParentAsync(const ::std::string& item, const Pose3D& pose, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &InnerModelManagerPrx::_iceI_setPoseFromParent, item, pose, context);
    }

    ::std::function<void()>
    setPoseFromParentAsync(const ::std::string& item, const Pose3D& pose,
                           ::std::function<void(bool)> response,
                           ::std::function<void(::std::exception_ptr)> ex = nullptr,
                           ::std::function<void(bool)> sent = nullptr,
                           const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(response, ex, sent, this, &RoboCompInnerModelManager::InnerModelManagerPrx::_iceI_setPoseFromParent, item, pose, context);
    }

    /// \cond INTERNAL
    void _iceI_setPoseFromParent(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::std::string&, const Pose3D&, const ::Ice::Context&);
    /// \endcond

    bool setScale(const ::std::string& item, float scaleX, float scaleY, float scaleZ, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &InnerModelManagerPrx::_iceI_setScale, item, scaleX, scaleY, scaleZ, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto setScaleAsync(const ::std::string& item, float scaleX, float scaleY, float scaleZ, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &InnerModelManagerPrx::_iceI_setScale, item, scaleX, scaleY, scaleZ, context);
    }

    ::std::function<void()>
    setScaleAsync(const ::std::string& item, float scaleX, float scaleY, float scaleZ,
                  ::std::function<void(bool)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(response, ex, sent, this, &RoboCompInnerModelManager::InnerModelManagerPrx::_iceI_setScale, item, scaleX, scaleY, scaleZ, context);
    }

    /// \cond INTERNAL
    void _iceI_setScale(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::std::string&, float, float, float, const ::Ice::Context&);
    /// \endcond

    bool transform(const ::std::string& base, const ::std::string& item, const coord3D& coordInItem, coord3D& coordInBase, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<InnerModelManager::TransformResult>(true, this, &InnerModelManagerPrx::_iceI_transform, base, item, coordInItem, context).get();
        coordInBase = ::std::move(_result.coordInBase);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto transformAsync(const ::std::string& base, const ::std::string& item, const coord3D& coordInItem, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<InnerModelManager::TransformResult>>().get_future())
    {
        return _makePromiseOutgoing<InnerModelManager::TransformResult, P>(false, this, &InnerModelManagerPrx::_iceI_transform, base, item, coordInItem, context);
    }

    ::std::function<void()>
    transformAsync(const ::std::string& base, const ::std::string& item, const coord3D& coordInItem,
                   ::std::function<void(bool, ::RoboCompInnerModelManager::coord3D)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](InnerModelManager::TransformResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.coordInBase));
        };
        return _makeLamdaOutgoing<InnerModelManager::TransformResult>(_responseCb, ex, sent, this, &RoboCompInnerModelManager::InnerModelManagerPrx::_iceI_transform, base, item, coordInItem, context);
    }

    /// \cond INTERNAL
    void _iceI_transform(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<InnerModelManager::TransformResult>>&, const ::std::string&, const ::std::string&, const coord3D&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    InnerModelManagerPrx() = default;
    friend ::std::shared_ptr<InnerModelManagerPrx> IceInternal::createProxy<InnerModelManagerPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits< ::RoboCompInnerModelManager::NodeType>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 12;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits<::RoboCompInnerModelManager::AttributeType>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 2;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::RoboCompInnerModelManager::AttributeType, S>
{
    static void read(S* istr, ::RoboCompInnerModelManager::AttributeType& v)
    {
        istr->readAll(v.type, v.value);
    }
};

template<>
struct StreamableTraits<::RoboCompInnerModelManager::NodeInformation>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 4;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::RoboCompInnerModelManager::NodeInformation, S>
{
    static void read(S* istr, ::RoboCompInnerModelManager::NodeInformation& v)
    {
        istr->readAll(v.id, v.parentId, v.nType, v.attributes);
    }
};

template<>
struct StreamableTraits< ::RoboCompInnerModelManager::ErrorType>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 9;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::RoboCompInnerModelManager::InnerModelManagerError, S>
{
    static void read(S* istr, ::RoboCompInnerModelManager::InnerModelManagerError& v)
    {
        istr->readAll(v.err, v.text);
    }
};

template<>
struct StreamableTraits<::RoboCompInnerModelManager::Colored3DPoint>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 15;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamReader<::RoboCompInnerModelManager::Colored3DPoint, S>
{
    static void read(S* istr, ::RoboCompInnerModelManager::Colored3DPoint& v)
    {
        istr->readAll(v.x, v.y, v.z, v.r, v.g, v.b);
    }
};

template<>
struct StreamableTraits<::RoboCompInnerModelManager::Plane3D>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 37;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::RoboCompInnerModelManager::Plane3D, S>
{
    static void read(S* istr, ::RoboCompInnerModelManager::Plane3D& v)
    {
        istr->readAll(v.px, v.py, v.pz, v.nx, v.ny, v.nz, v.width, v.height, v.thickness, v.texture);
    }
};

template<>
struct StreamableTraits<::RoboCompInnerModelManager::coord3D>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 12;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamReader<::RoboCompInnerModelManager::coord3D, S>
{
    static void read(S* istr, ::RoboCompInnerModelManager::coord3D& v)
    {
        istr->readAll(v.x, v.y, v.z);
    }
};

template<>
struct StreamableTraits<::RoboCompInnerModelManager::Pose3D>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 24;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamReader<::RoboCompInnerModelManager::Pose3D, S>
{
    static void read(S* istr, ::RoboCompInnerModelManager::Pose3D& v)
    {
        istr->readAll(v.x, v.y, v.z, v.rx, v.ry, v.rz);
    }
};

template<>
struct StreamableTraits<::RoboCompInnerModelManager::jointType>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 65;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::RoboCompInnerModelManager::jointType, S>
{
    static void read(S* istr, ::RoboCompInnerModelManager::jointType& v)
    {
        istr->readAll(v.pose, v.lx, v.ly, v.lz, v.hx, v.hy, v.hz, v.mass, v.min, v.max, v.axis, v.port);
    }
};

template<>
struct StreamableTraits<::RoboCompInnerModelManager::meshType>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 41;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::RoboCompInnerModelManager::meshType, S>
{
    static void read(S* istr, ::RoboCompInnerModelManager::meshType& v)
    {
        istr->readAll(v.pose, v.scaleX, v.scaleY, v.scaleZ, v.render, v.meshPath);
    }
};

template<>
struct StreamableTraits<::RoboCompInnerModelManager::Matrix>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 9;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::RoboCompInnerModelManager::Matrix, S>
{
    static void read(S* istr, ::RoboCompInnerModelManager::Matrix& v)
    {
        istr->readAll(v.cols, v.rows, v.data);
    }
};

}
/// \endcond

/// \cond INTERNAL
namespace RoboCompInnerModelManager
{

using InnerModelManagerPtr = ::std::shared_ptr<InnerModelManager>;
using InnerModelManagerPrxPtr = ::std::shared_ptr<InnerModelManagerPrx>;

}
/// \endcond

#else // C++98 mapping

namespace IceProxy
{

namespace RoboCompInnerModelManager
{

class InnerModelManager;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< InnerModelManager>&);
::IceProxy::Ice::Object* upCast(InnerModelManager*);
/// \endcond

}

}

namespace RoboCompInnerModelManager
{

class InnerModelManager;
/// \cond INTERNAL
::Ice::Object* upCast(InnerModelManager*);
/// \endcond
typedef ::IceInternal::Handle< InnerModelManager> InnerModelManagerPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::RoboCompInnerModelManager::InnerModelManager> InnerModelManagerPrx;
typedef InnerModelManagerPrx InnerModelManagerPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(InnerModelManagerPtr&, const ::Ice::ObjectPtr&);
/// \endcond

}

namespace RoboCompInnerModelManager
{

enum NodeType
{
    Transform,
    Joint,
    DifferentialRobot,
    OmniRobot,
    Plane,
    Camera,
    RGBD,
    IMU,
    Laser,
    Mesh,
    PointCloud,
    TouchSensor,
    DisplayII
};

struct AttributeType
{
    ::std::string type;
    ::std::string value;

    bool operator==(const AttributeType& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(type != rhs_.type)
        {
            return false;
        }
        if(value != rhs_.value)
        {
            return false;
        }
        return true;
    }

    bool operator<(const AttributeType& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(type < rhs_.type)
        {
            return true;
        }
        else if(rhs_.type < type)
        {
            return false;
        }
        if(value < rhs_.value)
        {
            return true;
        }
        else if(rhs_.value < value)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const AttributeType& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const AttributeType& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const AttributeType& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const AttributeType& rhs_) const
    {
        return !operator<(rhs_);
    }
};

typedef ::std::map< ::std::string, AttributeType> AttributeMap;

struct NodeInformation
{
    ::std::string id;
    ::std::string parentId;
    ::RoboCompInnerModelManager::NodeType nType;
    ::RoboCompInnerModelManager::AttributeMap attributes;
};

typedef ::std::vector<NodeInformation> NodeInformationSequence;

enum ErrorType
{
    NonExistingNode,
    NonExistingAttribute,
    NodeAlreadyExists,
    AttributeAlreadyExists,
    InvalidPath,
    InvalidEngine,
    InvalidValues,
    OperationInvalidNode,
    InternalError,
    Collision
};

class InnerModelManagerError : public ::Ice::UserException
{
public:

    InnerModelManagerError() {}
    /**
     * One-shot constructor to initialize all data members.
     */
    InnerModelManagerError(ErrorType err, const ::std::string& text);
    virtual ~InnerModelManagerError() throw();

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    virtual ::std::string ice_id() const;
    /**
     * Polymporphically clones this exception.
     * @return A shallow copy of this exception.
     */
    virtual InnerModelManagerError* ice_clone() const;
    /**
     * Throws this exception.
     */
    virtual void ice_throw() const;

    ::RoboCompInnerModelManager::ErrorType err;
    ::std::string text;

protected:

    /// \cond STREAM
    virtual void _writeImpl(::Ice::OutputStream*) const;
    virtual void _readImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
static InnerModelManagerError _iceS_InnerModelManagerError_init;
/// \endcond

struct Colored3DPoint
{
    ::Ice::Float x;
    ::Ice::Float y;
    ::Ice::Float z;
    ::Ice::Byte r;
    ::Ice::Byte g;
    ::Ice::Byte b;
};

typedef ::std::vector<Colored3DPoint> PointCloudVector;

struct Plane3D
{
    ::Ice::Float px;
    ::Ice::Float py;
    ::Ice::Float pz;
    ::Ice::Float nx;
    ::Ice::Float ny;
    ::Ice::Float nz;
    ::Ice::Float width;
    ::Ice::Float height;
    ::Ice::Float thickness;
    ::std::string texture;
};

struct coord3D
{
    ::Ice::Float x;
    ::Ice::Float y;
    ::Ice::Float z;
};

struct Pose3D
{
    ::Ice::Float x;
    ::Ice::Float y;
    ::Ice::Float z;
    ::Ice::Float rx;
    ::Ice::Float ry;
    ::Ice::Float rz;
};

struct jointType
{
    ::RoboCompInnerModelManager::Pose3D pose;
    ::Ice::Float lx;
    ::Ice::Float ly;
    ::Ice::Float lz;
    ::Ice::Float hx;
    ::Ice::Float hy;
    ::Ice::Float hz;
    ::Ice::Float mass;
    ::Ice::Float min;
    ::Ice::Float max;
    ::std::string axis;
    ::Ice::Int port;
};

struct meshType
{
    ::RoboCompInnerModelManager::Pose3D pose;
    ::Ice::Float scaleX;
    ::Ice::Float scaleY;
    ::Ice::Float scaleZ;
    ::Ice::Int render;
    ::std::string meshPath;
};

typedef ::std::vector< ::Ice::Float> FloatSeq;

struct Matrix
{
    ::Ice::Int cols;
    ::Ice::Int rows;
    ::RoboCompInnerModelManager::FloatSeq data;
};

}

namespace RoboCompInnerModelManager
{

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_addAttribute.
 * Create a wrapper instance by calling ::RoboCompInnerModelManager::newCallback_InnerModelManager_addAttribute.
 */
class Callback_InnerModelManager_addAttribute_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_InnerModelManager_addAttribute_Base> Callback_InnerModelManager_addAttributePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_addJoint.
 * Create a wrapper instance by calling ::RoboCompInnerModelManager::newCallback_InnerModelManager_addJoint.
 */
class Callback_InnerModelManager_addJoint_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_InnerModelManager_addJoint_Base> Callback_InnerModelManager_addJointPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_addMesh.
 * Create a wrapper instance by calling ::RoboCompInnerModelManager::newCallback_InnerModelManager_addMesh.
 */
class Callback_InnerModelManager_addMesh_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_InnerModelManager_addMesh_Base> Callback_InnerModelManager_addMeshPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_addPlane.
 * Create a wrapper instance by calling ::RoboCompInnerModelManager::newCallback_InnerModelManager_addPlane.
 */
class Callback_InnerModelManager_addPlane_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_InnerModelManager_addPlane_Base> Callback_InnerModelManager_addPlanePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_addTransform.
 * Create a wrapper instance by calling ::RoboCompInnerModelManager::newCallback_InnerModelManager_addTransform.
 */
class Callback_InnerModelManager_addTransform_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_InnerModelManager_addTransform_Base> Callback_InnerModelManager_addTransformPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_collide.
 * Create a wrapper instance by calling ::RoboCompInnerModelManager::newCallback_InnerModelManager_collide.
 */
class Callback_InnerModelManager_collide_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_InnerModelManager_collide_Base> Callback_InnerModelManager_collidePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_getAllNodeInformation.
 * Create a wrapper instance by calling ::RoboCompInnerModelManager::newCallback_InnerModelManager_getAllNodeInformation.
 */
class Callback_InnerModelManager_getAllNodeInformation_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_InnerModelManager_getAllNodeInformation_Base> Callback_InnerModelManager_getAllNodeInformationPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_getAttribute.
 * Create a wrapper instance by calling ::RoboCompInnerModelManager::newCallback_InnerModelManager_getAttribute.
 */
class Callback_InnerModelManager_getAttribute_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_InnerModelManager_getAttribute_Base> Callback_InnerModelManager_getAttributePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_getPose.
 * Create a wrapper instance by calling ::RoboCompInnerModelManager::newCallback_InnerModelManager_getPose.
 */
class Callback_InnerModelManager_getPose_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_InnerModelManager_getPose_Base> Callback_InnerModelManager_getPosePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_getPoseFromParent.
 * Create a wrapper instance by calling ::RoboCompInnerModelManager::newCallback_InnerModelManager_getPoseFromParent.
 */
class Callback_InnerModelManager_getPoseFromParent_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_InnerModelManager_getPoseFromParent_Base> Callback_InnerModelManager_getPoseFromParentPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_getTransformationMatrix.
 * Create a wrapper instance by calling ::RoboCompInnerModelManager::newCallback_InnerModelManager_getTransformationMatrix.
 */
class Callback_InnerModelManager_getTransformationMatrix_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_InnerModelManager_getTransformationMatrix_Base> Callback_InnerModelManager_getTransformationMatrixPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_moveNode.
 * Create a wrapper instance by calling ::RoboCompInnerModelManager::newCallback_InnerModelManager_moveNode.
 */
class Callback_InnerModelManager_moveNode_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_InnerModelManager_moveNode_Base> Callback_InnerModelManager_moveNodePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_removeAttribute.
 * Create a wrapper instance by calling ::RoboCompInnerModelManager::newCallback_InnerModelManager_removeAttribute.
 */
class Callback_InnerModelManager_removeAttribute_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_InnerModelManager_removeAttribute_Base> Callback_InnerModelManager_removeAttributePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_removeNode.
 * Create a wrapper instance by calling ::RoboCompInnerModelManager::newCallback_InnerModelManager_removeNode.
 */
class Callback_InnerModelManager_removeNode_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_InnerModelManager_removeNode_Base> Callback_InnerModelManager_removeNodePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_setAttribute.
 * Create a wrapper instance by calling ::RoboCompInnerModelManager::newCallback_InnerModelManager_setAttribute.
 */
class Callback_InnerModelManager_setAttribute_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_InnerModelManager_setAttribute_Base> Callback_InnerModelManager_setAttributePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_setPlane.
 * Create a wrapper instance by calling ::RoboCompInnerModelManager::newCallback_InnerModelManager_setPlane.
 */
class Callback_InnerModelManager_setPlane_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_InnerModelManager_setPlane_Base> Callback_InnerModelManager_setPlanePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_setPointCloudData.
 * Create a wrapper instance by calling ::RoboCompInnerModelManager::newCallback_InnerModelManager_setPointCloudData.
 */
class Callback_InnerModelManager_setPointCloudData_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_InnerModelManager_setPointCloudData_Base> Callback_InnerModelManager_setPointCloudDataPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_setPose.
 * Create a wrapper instance by calling ::RoboCompInnerModelManager::newCallback_InnerModelManager_setPose.
 */
class Callback_InnerModelManager_setPose_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_InnerModelManager_setPose_Base> Callback_InnerModelManager_setPosePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_setPoseFromParent.
 * Create a wrapper instance by calling ::RoboCompInnerModelManager::newCallback_InnerModelManager_setPoseFromParent.
 */
class Callback_InnerModelManager_setPoseFromParent_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_InnerModelManager_setPoseFromParent_Base> Callback_InnerModelManager_setPoseFromParentPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_setScale.
 * Create a wrapper instance by calling ::RoboCompInnerModelManager::newCallback_InnerModelManager_setScale.
 */
class Callback_InnerModelManager_setScale_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_InnerModelManager_setScale_Base> Callback_InnerModelManager_setScalePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_transform.
 * Create a wrapper instance by calling ::RoboCompInnerModelManager::newCallback_InnerModelManager_transform.
 */
class Callback_InnerModelManager_transform_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_InnerModelManager_transform_Base> Callback_InnerModelManager_transformPtr;

}

namespace IceProxy
{

namespace RoboCompInnerModelManager
{

class InnerModelManager : public virtual ::Ice::Proxy<InnerModelManager, ::IceProxy::Ice::Object>
{
public:

    bool addAttribute(const ::std::string& idNode, const ::std::string& name, const ::std::string& type, const ::std::string& value, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_addAttribute(_iceI_begin_addAttribute(idNode, name, type, value, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_addAttribute(const ::std::string& idNode, const ::std::string& name, const ::std::string& type, const ::std::string& value, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_addAttribute(idNode, name, type, value, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_addAttribute(const ::std::string& idNode, const ::std::string& name, const ::std::string& type, const ::std::string& value, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_addAttribute(idNode, name, type, value, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_addAttribute(const ::std::string& idNode, const ::std::string& name, const ::std::string& type, const ::std::string& value, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_addAttribute(idNode, name, type, value, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_addAttribute(const ::std::string& idNode, const ::std::string& name, const ::std::string& type, const ::std::string& value, const ::RoboCompInnerModelManager::Callback_InnerModelManager_addAttributePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_addAttribute(idNode, name, type, value, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_addAttribute(const ::std::string& idNode, const ::std::string& name, const ::std::string& type, const ::std::string& value, const ::Ice::Context& context, const ::RoboCompInnerModelManager::Callback_InnerModelManager_addAttributePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_addAttribute(idNode, name, type, value, context, cb, cookie);
    }

    bool end_addAttribute(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_addAttribute(const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool addJoint(const ::std::string& item, const ::std::string& base, const ::RoboCompInnerModelManager::jointType& j, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_addJoint(_iceI_begin_addJoint(item, base, j, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_addJoint(const ::std::string& item, const ::std::string& base, const ::RoboCompInnerModelManager::jointType& j, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_addJoint(item, base, j, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_addJoint(const ::std::string& item, const ::std::string& base, const ::RoboCompInnerModelManager::jointType& j, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_addJoint(item, base, j, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_addJoint(const ::std::string& item, const ::std::string& base, const ::RoboCompInnerModelManager::jointType& j, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_addJoint(item, base, j, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_addJoint(const ::std::string& item, const ::std::string& base, const ::RoboCompInnerModelManager::jointType& j, const ::RoboCompInnerModelManager::Callback_InnerModelManager_addJointPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_addJoint(item, base, j, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_addJoint(const ::std::string& item, const ::std::string& base, const ::RoboCompInnerModelManager::jointType& j, const ::Ice::Context& context, const ::RoboCompInnerModelManager::Callback_InnerModelManager_addJointPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_addJoint(item, base, j, context, cb, cookie);
    }

    bool end_addJoint(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_addJoint(const ::std::string&, const ::std::string&, const ::RoboCompInnerModelManager::jointType&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool addMesh(const ::std::string& item, const ::std::string& base, const ::RoboCompInnerModelManager::meshType& m, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_addMesh(_iceI_begin_addMesh(item, base, m, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_addMesh(const ::std::string& item, const ::std::string& base, const ::RoboCompInnerModelManager::meshType& m, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_addMesh(item, base, m, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_addMesh(const ::std::string& item, const ::std::string& base, const ::RoboCompInnerModelManager::meshType& m, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_addMesh(item, base, m, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_addMesh(const ::std::string& item, const ::std::string& base, const ::RoboCompInnerModelManager::meshType& m, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_addMesh(item, base, m, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_addMesh(const ::std::string& item, const ::std::string& base, const ::RoboCompInnerModelManager::meshType& m, const ::RoboCompInnerModelManager::Callback_InnerModelManager_addMeshPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_addMesh(item, base, m, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_addMesh(const ::std::string& item, const ::std::string& base, const ::RoboCompInnerModelManager::meshType& m, const ::Ice::Context& context, const ::RoboCompInnerModelManager::Callback_InnerModelManager_addMeshPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_addMesh(item, base, m, context, cb, cookie);
    }

    bool end_addMesh(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_addMesh(const ::std::string&, const ::std::string&, const ::RoboCompInnerModelManager::meshType&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool addPlane(const ::std::string& item, const ::std::string& base, const ::RoboCompInnerModelManager::Plane3D& plane, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_addPlane(_iceI_begin_addPlane(item, base, plane, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_addPlane(const ::std::string& item, const ::std::string& base, const ::RoboCompInnerModelManager::Plane3D& plane, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_addPlane(item, base, plane, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_addPlane(const ::std::string& item, const ::std::string& base, const ::RoboCompInnerModelManager::Plane3D& plane, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_addPlane(item, base, plane, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_addPlane(const ::std::string& item, const ::std::string& base, const ::RoboCompInnerModelManager::Plane3D& plane, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_addPlane(item, base, plane, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_addPlane(const ::std::string& item, const ::std::string& base, const ::RoboCompInnerModelManager::Plane3D& plane, const ::RoboCompInnerModelManager::Callback_InnerModelManager_addPlanePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_addPlane(item, base, plane, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_addPlane(const ::std::string& item, const ::std::string& base, const ::RoboCompInnerModelManager::Plane3D& plane, const ::Ice::Context& context, const ::RoboCompInnerModelManager::Callback_InnerModelManager_addPlanePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_addPlane(item, base, plane, context, cb, cookie);
    }

    bool end_addPlane(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_addPlane(const ::std::string&, const ::std::string&, const ::RoboCompInnerModelManager::Plane3D&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool addTransform(const ::std::string& item, const ::std::string& engine, const ::std::string& base, const ::RoboCompInnerModelManager::Pose3D& pose, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_addTransform(_iceI_begin_addTransform(item, engine, base, pose, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_addTransform(const ::std::string& item, const ::std::string& engine, const ::std::string& base, const ::RoboCompInnerModelManager::Pose3D& pose, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_addTransform(item, engine, base, pose, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_addTransform(const ::std::string& item, const ::std::string& engine, const ::std::string& base, const ::RoboCompInnerModelManager::Pose3D& pose, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_addTransform(item, engine, base, pose, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_addTransform(const ::std::string& item, const ::std::string& engine, const ::std::string& base, const ::RoboCompInnerModelManager::Pose3D& pose, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_addTransform(item, engine, base, pose, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_addTransform(const ::std::string& item, const ::std::string& engine, const ::std::string& base, const ::RoboCompInnerModelManager::Pose3D& pose, const ::RoboCompInnerModelManager::Callback_InnerModelManager_addTransformPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_addTransform(item, engine, base, pose, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_addTransform(const ::std::string& item, const ::std::string& engine, const ::std::string& base, const ::RoboCompInnerModelManager::Pose3D& pose, const ::Ice::Context& context, const ::RoboCompInnerModelManager::Callback_InnerModelManager_addTransformPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_addTransform(item, engine, base, pose, context, cb, cookie);
    }

    bool end_addTransform(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_addTransform(const ::std::string&, const ::std::string&, const ::std::string&, const ::RoboCompInnerModelManager::Pose3D&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool collide(const ::std::string& a, const ::std::string& b, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_collide(_iceI_begin_collide(a, b, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_collide(const ::std::string& a, const ::std::string& b, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_collide(a, b, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_collide(const ::std::string& a, const ::std::string& b, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_collide(a, b, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_collide(const ::std::string& a, const ::std::string& b, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_collide(a, b, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_collide(const ::std::string& a, const ::std::string& b, const ::RoboCompInnerModelManager::Callback_InnerModelManager_collidePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_collide(a, b, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_collide(const ::std::string& a, const ::std::string& b, const ::Ice::Context& context, const ::RoboCompInnerModelManager::Callback_InnerModelManager_collidePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_collide(a, b, context, cb, cookie);
    }

    bool end_collide(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_collide(const ::std::string&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void getAllNodeInformation(::RoboCompInnerModelManager::NodeInformationSequence& nodesInfo, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_getAllNodeInformation(nodesInfo, _iceI_begin_getAllNodeInformation(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getAllNodeInformation(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getAllNodeInformation(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getAllNodeInformation(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getAllNodeInformation(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getAllNodeInformation(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getAllNodeInformation(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getAllNodeInformation(const ::RoboCompInnerModelManager::Callback_InnerModelManager_getAllNodeInformationPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getAllNodeInformation(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getAllNodeInformation(const ::Ice::Context& context, const ::RoboCompInnerModelManager::Callback_InnerModelManager_getAllNodeInformationPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getAllNodeInformation(context, cb, cookie);
    }

    void end_getAllNodeInformation(::RoboCompInnerModelManager::NodeInformationSequence& nodesInfo, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_getAllNodeInformation(::RoboCompInnerModelManager::NodeInformationSequence& iceP_nodesInfo, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_getAllNodeInformation(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool getAttribute(const ::std::string& idNode, const ::std::string& name, ::std::string& type, ::std::string& value, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getAttribute(type, value, _iceI_begin_getAttribute(idNode, name, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getAttribute(const ::std::string& idNode, const ::std::string& name, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getAttribute(idNode, name, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getAttribute(const ::std::string& idNode, const ::std::string& name, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getAttribute(idNode, name, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getAttribute(const ::std::string& idNode, const ::std::string& name, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getAttribute(idNode, name, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getAttribute(const ::std::string& idNode, const ::std::string& name, const ::RoboCompInnerModelManager::Callback_InnerModelManager_getAttributePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getAttribute(idNode, name, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getAttribute(const ::std::string& idNode, const ::std::string& name, const ::Ice::Context& context, const ::RoboCompInnerModelManager::Callback_InnerModelManager_getAttributePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getAttribute(idNode, name, context, cb, cookie);
    }

    bool end_getAttribute(::std::string& type, ::std::string& value, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_getAttribute(::std::string& iceP_type, ::std::string& iceP_value, bool& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_getAttribute(const ::std::string&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool getPose(const ::std::string& base, const ::std::string& item, ::RoboCompInnerModelManager::Pose3D& pose, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getPose(pose, _iceI_begin_getPose(base, item, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getPose(const ::std::string& base, const ::std::string& item, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getPose(base, item, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getPose(const ::std::string& base, const ::std::string& item, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getPose(base, item, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getPose(const ::std::string& base, const ::std::string& item, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getPose(base, item, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getPose(const ::std::string& base, const ::std::string& item, const ::RoboCompInnerModelManager::Callback_InnerModelManager_getPosePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getPose(base, item, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getPose(const ::std::string& base, const ::std::string& item, const ::Ice::Context& context, const ::RoboCompInnerModelManager::Callback_InnerModelManager_getPosePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getPose(base, item, context, cb, cookie);
    }

    bool end_getPose(::RoboCompInnerModelManager::Pose3D& pose, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_getPose(::RoboCompInnerModelManager::Pose3D& iceP_pose, bool& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_getPose(const ::std::string&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool getPoseFromParent(const ::std::string& item, ::RoboCompInnerModelManager::Pose3D& pose, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getPoseFromParent(pose, _iceI_begin_getPoseFromParent(item, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getPoseFromParent(const ::std::string& item, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getPoseFromParent(item, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getPoseFromParent(const ::std::string& item, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getPoseFromParent(item, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getPoseFromParent(const ::std::string& item, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getPoseFromParent(item, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getPoseFromParent(const ::std::string& item, const ::RoboCompInnerModelManager::Callback_InnerModelManager_getPoseFromParentPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getPoseFromParent(item, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getPoseFromParent(const ::std::string& item, const ::Ice::Context& context, const ::RoboCompInnerModelManager::Callback_InnerModelManager_getPoseFromParentPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getPoseFromParent(item, context, cb, cookie);
    }

    bool end_getPoseFromParent(::RoboCompInnerModelManager::Pose3D& pose, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_getPoseFromParent(::RoboCompInnerModelManager::Pose3D& iceP_pose, bool& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_getPoseFromParent(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::RoboCompInnerModelManager::Matrix getTransformationMatrix(const ::std::string& base, const ::std::string& item, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getTransformationMatrix(_iceI_begin_getTransformationMatrix(base, item, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getTransformationMatrix(const ::std::string& base, const ::std::string& item, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getTransformationMatrix(base, item, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getTransformationMatrix(const ::std::string& base, const ::std::string& item, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getTransformationMatrix(base, item, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getTransformationMatrix(const ::std::string& base, const ::std::string& item, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getTransformationMatrix(base, item, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getTransformationMatrix(const ::std::string& base, const ::std::string& item, const ::RoboCompInnerModelManager::Callback_InnerModelManager_getTransformationMatrixPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getTransformationMatrix(base, item, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getTransformationMatrix(const ::std::string& base, const ::std::string& item, const ::Ice::Context& context, const ::RoboCompInnerModelManager::Callback_InnerModelManager_getTransformationMatrixPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getTransformationMatrix(base, item, context, cb, cookie);
    }

    ::RoboCompInnerModelManager::Matrix end_getTransformationMatrix(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getTransformationMatrix(const ::std::string&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool moveNode(const ::std::string& src, const ::std::string& dst, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_moveNode(_iceI_begin_moveNode(src, dst, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_moveNode(const ::std::string& src, const ::std::string& dst, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_moveNode(src, dst, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_moveNode(const ::std::string& src, const ::std::string& dst, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_moveNode(src, dst, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_moveNode(const ::std::string& src, const ::std::string& dst, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_moveNode(src, dst, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_moveNode(const ::std::string& src, const ::std::string& dst, const ::RoboCompInnerModelManager::Callback_InnerModelManager_moveNodePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_moveNode(src, dst, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_moveNode(const ::std::string& src, const ::std::string& dst, const ::Ice::Context& context, const ::RoboCompInnerModelManager::Callback_InnerModelManager_moveNodePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_moveNode(src, dst, context, cb, cookie);
    }

    bool end_moveNode(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_moveNode(const ::std::string&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool removeAttribute(const ::std::string& idNode, const ::std::string& name, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_removeAttribute(_iceI_begin_removeAttribute(idNode, name, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_removeAttribute(const ::std::string& idNode, const ::std::string& name, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_removeAttribute(idNode, name, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_removeAttribute(const ::std::string& idNode, const ::std::string& name, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_removeAttribute(idNode, name, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_removeAttribute(const ::std::string& idNode, const ::std::string& name, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_removeAttribute(idNode, name, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_removeAttribute(const ::std::string& idNode, const ::std::string& name, const ::RoboCompInnerModelManager::Callback_InnerModelManager_removeAttributePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_removeAttribute(idNode, name, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_removeAttribute(const ::std::string& idNode, const ::std::string& name, const ::Ice::Context& context, const ::RoboCompInnerModelManager::Callback_InnerModelManager_removeAttributePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_removeAttribute(idNode, name, context, cb, cookie);
    }

    bool end_removeAttribute(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_removeAttribute(const ::std::string&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool removeNode(const ::std::string& item, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_removeNode(_iceI_begin_removeNode(item, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_removeNode(const ::std::string& item, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_removeNode(item, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_removeNode(const ::std::string& item, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_removeNode(item, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_removeNode(const ::std::string& item, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_removeNode(item, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_removeNode(const ::std::string& item, const ::RoboCompInnerModelManager::Callback_InnerModelManager_removeNodePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_removeNode(item, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_removeNode(const ::std::string& item, const ::Ice::Context& context, const ::RoboCompInnerModelManager::Callback_InnerModelManager_removeNodePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_removeNode(item, context, cb, cookie);
    }

    bool end_removeNode(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_removeNode(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool setAttribute(const ::std::string& idNode, const ::std::string& name, const ::std::string& type, const ::std::string& value, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_setAttribute(_iceI_begin_setAttribute(idNode, name, type, value, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_setAttribute(const ::std::string& idNode, const ::std::string& name, const ::std::string& type, const ::std::string& value, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_setAttribute(idNode, name, type, value, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setAttribute(const ::std::string& idNode, const ::std::string& name, const ::std::string& type, const ::std::string& value, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setAttribute(idNode, name, type, value, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setAttribute(const ::std::string& idNode, const ::std::string& name, const ::std::string& type, const ::std::string& value, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setAttribute(idNode, name, type, value, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setAttribute(const ::std::string& idNode, const ::std::string& name, const ::std::string& type, const ::std::string& value, const ::RoboCompInnerModelManager::Callback_InnerModelManager_setAttributePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setAttribute(idNode, name, type, value, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setAttribute(const ::std::string& idNode, const ::std::string& name, const ::std::string& type, const ::std::string& value, const ::Ice::Context& context, const ::RoboCompInnerModelManager::Callback_InnerModelManager_setAttributePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setAttribute(idNode, name, type, value, context, cb, cookie);
    }

    bool end_setAttribute(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_setAttribute(const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool setPlane(const ::std::string& item, const ::RoboCompInnerModelManager::Plane3D& plane, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_setPlane(_iceI_begin_setPlane(item, plane, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_setPlane(const ::std::string& item, const ::RoboCompInnerModelManager::Plane3D& plane, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_setPlane(item, plane, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setPlane(const ::std::string& item, const ::RoboCompInnerModelManager::Plane3D& plane, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setPlane(item, plane, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setPlane(const ::std::string& item, const ::RoboCompInnerModelManager::Plane3D& plane, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setPlane(item, plane, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setPlane(const ::std::string& item, const ::RoboCompInnerModelManager::Plane3D& plane, const ::RoboCompInnerModelManager::Callback_InnerModelManager_setPlanePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setPlane(item, plane, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setPlane(const ::std::string& item, const ::RoboCompInnerModelManager::Plane3D& plane, const ::Ice::Context& context, const ::RoboCompInnerModelManager::Callback_InnerModelManager_setPlanePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setPlane(item, plane, context, cb, cookie);
    }

    bool end_setPlane(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_setPlane(const ::std::string&, const ::RoboCompInnerModelManager::Plane3D&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void setPointCloudData(const ::std::string& id, const ::RoboCompInnerModelManager::PointCloudVector& cloud, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_setPointCloudData(_iceI_begin_setPointCloudData(id, cloud, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_setPointCloudData(const ::std::string& id, const ::RoboCompInnerModelManager::PointCloudVector& cloud, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_setPointCloudData(id, cloud, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setPointCloudData(const ::std::string& id, const ::RoboCompInnerModelManager::PointCloudVector& cloud, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setPointCloudData(id, cloud, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setPointCloudData(const ::std::string& id, const ::RoboCompInnerModelManager::PointCloudVector& cloud, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setPointCloudData(id, cloud, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setPointCloudData(const ::std::string& id, const ::RoboCompInnerModelManager::PointCloudVector& cloud, const ::RoboCompInnerModelManager::Callback_InnerModelManager_setPointCloudDataPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setPointCloudData(id, cloud, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setPointCloudData(const ::std::string& id, const ::RoboCompInnerModelManager::PointCloudVector& cloud, const ::Ice::Context& context, const ::RoboCompInnerModelManager::Callback_InnerModelManager_setPointCloudDataPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setPointCloudData(id, cloud, context, cb, cookie);
    }

    void end_setPointCloudData(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_setPointCloudData(const ::std::string&, const ::RoboCompInnerModelManager::PointCloudVector&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool setPose(const ::std::string& base, const ::std::string& item, const ::RoboCompInnerModelManager::Pose3D& pose, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_setPose(_iceI_begin_setPose(base, item, pose, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_setPose(const ::std::string& base, const ::std::string& item, const ::RoboCompInnerModelManager::Pose3D& pose, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_setPose(base, item, pose, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setPose(const ::std::string& base, const ::std::string& item, const ::RoboCompInnerModelManager::Pose3D& pose, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setPose(base, item, pose, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setPose(const ::std::string& base, const ::std::string& item, const ::RoboCompInnerModelManager::Pose3D& pose, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setPose(base, item, pose, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setPose(const ::std::string& base, const ::std::string& item, const ::RoboCompInnerModelManager::Pose3D& pose, const ::RoboCompInnerModelManager::Callback_InnerModelManager_setPosePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setPose(base, item, pose, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setPose(const ::std::string& base, const ::std::string& item, const ::RoboCompInnerModelManager::Pose3D& pose, const ::Ice::Context& context, const ::RoboCompInnerModelManager::Callback_InnerModelManager_setPosePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setPose(base, item, pose, context, cb, cookie);
    }

    bool end_setPose(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_setPose(const ::std::string&, const ::std::string&, const ::RoboCompInnerModelManager::Pose3D&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool setPoseFromParent(const ::std::string& item, const ::RoboCompInnerModelManager::Pose3D& pose, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_setPoseFromParent(_iceI_begin_setPoseFromParent(item, pose, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_setPoseFromParent(const ::std::string& item, const ::RoboCompInnerModelManager::Pose3D& pose, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_setPoseFromParent(item, pose, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setPoseFromParent(const ::std::string& item, const ::RoboCompInnerModelManager::Pose3D& pose, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setPoseFromParent(item, pose, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setPoseFromParent(const ::std::string& item, const ::RoboCompInnerModelManager::Pose3D& pose, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setPoseFromParent(item, pose, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setPoseFromParent(const ::std::string& item, const ::RoboCompInnerModelManager::Pose3D& pose, const ::RoboCompInnerModelManager::Callback_InnerModelManager_setPoseFromParentPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setPoseFromParent(item, pose, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setPoseFromParent(const ::std::string& item, const ::RoboCompInnerModelManager::Pose3D& pose, const ::Ice::Context& context, const ::RoboCompInnerModelManager::Callback_InnerModelManager_setPoseFromParentPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setPoseFromParent(item, pose, context, cb, cookie);
    }

    bool end_setPoseFromParent(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_setPoseFromParent(const ::std::string&, const ::RoboCompInnerModelManager::Pose3D&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool setScale(const ::std::string& item, ::Ice::Float scaleX, ::Ice::Float scaleY, ::Ice::Float scaleZ, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_setScale(_iceI_begin_setScale(item, scaleX, scaleY, scaleZ, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_setScale(const ::std::string& item, ::Ice::Float scaleX, ::Ice::Float scaleY, ::Ice::Float scaleZ, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_setScale(item, scaleX, scaleY, scaleZ, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setScale(const ::std::string& item, ::Ice::Float scaleX, ::Ice::Float scaleY, ::Ice::Float scaleZ, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setScale(item, scaleX, scaleY, scaleZ, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setScale(const ::std::string& item, ::Ice::Float scaleX, ::Ice::Float scaleY, ::Ice::Float scaleZ, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setScale(item, scaleX, scaleY, scaleZ, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setScale(const ::std::string& item, ::Ice::Float scaleX, ::Ice::Float scaleY, ::Ice::Float scaleZ, const ::RoboCompInnerModelManager::Callback_InnerModelManager_setScalePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setScale(item, scaleX, scaleY, scaleZ, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setScale(const ::std::string& item, ::Ice::Float scaleX, ::Ice::Float scaleY, ::Ice::Float scaleZ, const ::Ice::Context& context, const ::RoboCompInnerModelManager::Callback_InnerModelManager_setScalePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setScale(item, scaleX, scaleY, scaleZ, context, cb, cookie);
    }

    bool end_setScale(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_setScale(const ::std::string&, ::Ice::Float, ::Ice::Float, ::Ice::Float, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool transform(const ::std::string& base, const ::std::string& item, const ::RoboCompInnerModelManager::coord3D& coordInItem, ::RoboCompInnerModelManager::coord3D& coordInBase, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_transform(coordInBase, _iceI_begin_transform(base, item, coordInItem, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_transform(const ::std::string& base, const ::std::string& item, const ::RoboCompInnerModelManager::coord3D& coordInItem, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_transform(base, item, coordInItem, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_transform(const ::std::string& base, const ::std::string& item, const ::RoboCompInnerModelManager::coord3D& coordInItem, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_transform(base, item, coordInItem, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_transform(const ::std::string& base, const ::std::string& item, const ::RoboCompInnerModelManager::coord3D& coordInItem, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_transform(base, item, coordInItem, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_transform(const ::std::string& base, const ::std::string& item, const ::RoboCompInnerModelManager::coord3D& coordInItem, const ::RoboCompInnerModelManager::Callback_InnerModelManager_transformPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_transform(base, item, coordInItem, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_transform(const ::std::string& base, const ::std::string& item, const ::RoboCompInnerModelManager::coord3D& coordInItem, const ::Ice::Context& context, const ::RoboCompInnerModelManager::Callback_InnerModelManager_transformPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_transform(base, item, coordInItem, context, cb, cookie);
    }

    bool end_transform(::RoboCompInnerModelManager::coord3D& coordInBase, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_transform(::RoboCompInnerModelManager::coord3D& iceP_coordInBase, bool& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_transform(const ::std::string&, const ::std::string&, const ::RoboCompInnerModelManager::coord3D&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

}

}

namespace RoboCompInnerModelManager
{

class InnerModelManager : public virtual ::Ice::Object
{
public:

    typedef InnerModelManagerPrx ProxyType;
    typedef InnerModelManagerPtr PointerType;

    virtual ~InnerModelManager();

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual bool addAttribute(const ::std::string& idNode, const ::std::string& name, const ::std::string& type, const ::std::string& value, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_addAttribute(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool addJoint(const ::std::string& item, const ::std::string& base, const jointType& j, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_addJoint(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool addMesh(const ::std::string& item, const ::std::string& base, const meshType& m, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_addMesh(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool addPlane(const ::std::string& item, const ::std::string& base, const Plane3D& plane, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_addPlane(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool addTransform(const ::std::string& item, const ::std::string& engine, const ::std::string& base, const Pose3D& pose, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_addTransform(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool collide(const ::std::string& a, const ::std::string& b, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_collide(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void getAllNodeInformation(NodeInformationSequence& nodesInfo, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getAllNodeInformation(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool getAttribute(const ::std::string& idNode, const ::std::string& name, ::std::string& type, ::std::string& value, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getAttribute(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool getPose(const ::std::string& base, const ::std::string& item, Pose3D& pose, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getPose(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool getPoseFromParent(const ::std::string& item, Pose3D& pose, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getPoseFromParent(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual Matrix getTransformationMatrix(const ::std::string& base, const ::std::string& item, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getTransformationMatrix(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool moveNode(const ::std::string& src, const ::std::string& dst, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_moveNode(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool removeAttribute(const ::std::string& idNode, const ::std::string& name, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_removeAttribute(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool removeNode(const ::std::string& item, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_removeNode(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool setAttribute(const ::std::string& idNode, const ::std::string& name, const ::std::string& type, const ::std::string& value, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_setAttribute(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool setPlane(const ::std::string& item, const Plane3D& plane, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_setPlane(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void setPointCloudData(const ::std::string& id, const PointCloudVector& cloud, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_setPointCloudData(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool setPose(const ::std::string& base, const ::std::string& item, const Pose3D& pose, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_setPose(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool setPoseFromParent(const ::std::string& item, const Pose3D& pose, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_setPoseFromParent(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool setScale(const ::std::string& item, ::Ice::Float scaleX, ::Ice::Float scaleY, ::Ice::Float scaleZ, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_setScale(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool transform(const ::std::string& base, const ::std::string& item, const coord3D& coordInItem, coord3D& coordInBase, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_transform(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const InnerModelManager& lhs, const InnerModelManager& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const InnerModelManager& lhs, const InnerModelManager& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits< ::RoboCompInnerModelManager::NodeType>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 12;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::RoboCompInnerModelManager::AttributeType>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 2;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::RoboCompInnerModelManager::AttributeType, S>
{
    static void write(S* ostr, const ::RoboCompInnerModelManager::AttributeType& v)
    {
        ostr->write(v.type);
        ostr->write(v.value);
    }
};

template<typename S>
struct StreamReader< ::RoboCompInnerModelManager::AttributeType, S>
{
    static void read(S* istr, ::RoboCompInnerModelManager::AttributeType& v)
    {
        istr->read(v.type);
        istr->read(v.value);
    }
};

template<>
struct StreamableTraits< ::RoboCompInnerModelManager::NodeInformation>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 4;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::RoboCompInnerModelManager::NodeInformation, S>
{
    static void write(S* ostr, const ::RoboCompInnerModelManager::NodeInformation& v)
    {
        ostr->write(v.id);
        ostr->write(v.parentId);
        ostr->write(v.nType);
        ostr->write(v.attributes);
    }
};

template<typename S>
struct StreamReader< ::RoboCompInnerModelManager::NodeInformation, S>
{
    static void read(S* istr, ::RoboCompInnerModelManager::NodeInformation& v)
    {
        istr->read(v.id);
        istr->read(v.parentId);
        istr->read(v.nType);
        istr->read(v.attributes);
    }
};

template<>
struct StreamableTraits< ::RoboCompInnerModelManager::ErrorType>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 9;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::RoboCompInnerModelManager::InnerModelManagerError>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<typename S>
struct StreamWriter< ::RoboCompInnerModelManager::InnerModelManagerError, S>
{
    static void write(S* ostr, const ::RoboCompInnerModelManager::InnerModelManagerError& v)
    {
        ostr->write(v.err);
        ostr->write(v.text);
    }
};

template<typename S>
struct StreamReader< ::RoboCompInnerModelManager::InnerModelManagerError, S>
{
    static void read(S* istr, ::RoboCompInnerModelManager::InnerModelManagerError& v)
    {
        istr->read(v.err);
        istr->read(v.text);
    }
};

template<>
struct StreamableTraits< ::RoboCompInnerModelManager::Colored3DPoint>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 15;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamWriter< ::RoboCompInnerModelManager::Colored3DPoint, S>
{
    static void write(S* ostr, const ::RoboCompInnerModelManager::Colored3DPoint& v)
    {
        ostr->write(v.x);
        ostr->write(v.y);
        ostr->write(v.z);
        ostr->write(v.r);
        ostr->write(v.g);
        ostr->write(v.b);
    }
};

template<typename S>
struct StreamReader< ::RoboCompInnerModelManager::Colored3DPoint, S>
{
    static void read(S* istr, ::RoboCompInnerModelManager::Colored3DPoint& v)
    {
        istr->read(v.x);
        istr->read(v.y);
        istr->read(v.z);
        istr->read(v.r);
        istr->read(v.g);
        istr->read(v.b);
    }
};

template<>
struct StreamableTraits< ::RoboCompInnerModelManager::Plane3D>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 37;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::RoboCompInnerModelManager::Plane3D, S>
{
    static void write(S* ostr, const ::RoboCompInnerModelManager::Plane3D& v)
    {
        ostr->write(v.px);
        ostr->write(v.py);
        ostr->write(v.pz);
        ostr->write(v.nx);
        ostr->write(v.ny);
        ostr->write(v.nz);
        ostr->write(v.width);
        ostr->write(v.height);
        ostr->write(v.thickness);
        ostr->write(v.texture);
    }
};

template<typename S>
struct StreamReader< ::RoboCompInnerModelManager::Plane3D, S>
{
    static void read(S* istr, ::RoboCompInnerModelManager::Plane3D& v)
    {
        istr->read(v.px);
        istr->read(v.py);
        istr->read(v.pz);
        istr->read(v.nx);
        istr->read(v.ny);
        istr->read(v.nz);
        istr->read(v.width);
        istr->read(v.height);
        istr->read(v.thickness);
        istr->read(v.texture);
    }
};

template<>
struct StreamableTraits< ::RoboCompInnerModelManager::coord3D>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 12;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamWriter< ::RoboCompInnerModelManager::coord3D, S>
{
    static void write(S* ostr, const ::RoboCompInnerModelManager::coord3D& v)
    {
        ostr->write(v.x);
        ostr->write(v.y);
        ostr->write(v.z);
    }
};

template<typename S>
struct StreamReader< ::RoboCompInnerModelManager::coord3D, S>
{
    static void read(S* istr, ::RoboCompInnerModelManager::coord3D& v)
    {
        istr->read(v.x);
        istr->read(v.y);
        istr->read(v.z);
    }
};

template<>
struct StreamableTraits< ::RoboCompInnerModelManager::Pose3D>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 24;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamWriter< ::RoboCompInnerModelManager::Pose3D, S>
{
    static void write(S* ostr, const ::RoboCompInnerModelManager::Pose3D& v)
    {
        ostr->write(v.x);
        ostr->write(v.y);
        ostr->write(v.z);
        ostr->write(v.rx);
        ostr->write(v.ry);
        ostr->write(v.rz);
    }
};

template<typename S>
struct StreamReader< ::RoboCompInnerModelManager::Pose3D, S>
{
    static void read(S* istr, ::RoboCompInnerModelManager::Pose3D& v)
    {
        istr->read(v.x);
        istr->read(v.y);
        istr->read(v.z);
        istr->read(v.rx);
        istr->read(v.ry);
        istr->read(v.rz);
    }
};

template<>
struct StreamableTraits< ::RoboCompInnerModelManager::jointType>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 65;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::RoboCompInnerModelManager::jointType, S>
{
    static void write(S* ostr, const ::RoboCompInnerModelManager::jointType& v)
    {
        ostr->write(v.pose);
        ostr->write(v.lx);
        ostr->write(v.ly);
        ostr->write(v.lz);
        ostr->write(v.hx);
        ostr->write(v.hy);
        ostr->write(v.hz);
        ostr->write(v.mass);
        ostr->write(v.min);
        ostr->write(v.max);
        ostr->write(v.axis);
        ostr->write(v.port);
    }
};

template<typename S>
struct StreamReader< ::RoboCompInnerModelManager::jointType, S>
{
    static void read(S* istr, ::RoboCompInnerModelManager::jointType& v)
    {
        istr->read(v.pose);
        istr->read(v.lx);
        istr->read(v.ly);
        istr->read(v.lz);
        istr->read(v.hx);
        istr->read(v.hy);
        istr->read(v.hz);
        istr->read(v.mass);
        istr->read(v.min);
        istr->read(v.max);
        istr->read(v.axis);
        istr->read(v.port);
    }
};

template<>
struct StreamableTraits< ::RoboCompInnerModelManager::meshType>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 41;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::RoboCompInnerModelManager::meshType, S>
{
    static void write(S* ostr, const ::RoboCompInnerModelManager::meshType& v)
    {
        ostr->write(v.pose);
        ostr->write(v.scaleX);
        ostr->write(v.scaleY);
        ostr->write(v.scaleZ);
        ostr->write(v.render);
        ostr->write(v.meshPath);
    }
};

template<typename S>
struct StreamReader< ::RoboCompInnerModelManager::meshType, S>
{
    static void read(S* istr, ::RoboCompInnerModelManager::meshType& v)
    {
        istr->read(v.pose);
        istr->read(v.scaleX);
        istr->read(v.scaleY);
        istr->read(v.scaleZ);
        istr->read(v.render);
        istr->read(v.meshPath);
    }
};

template<>
struct StreamableTraits< ::RoboCompInnerModelManager::Matrix>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 9;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::RoboCompInnerModelManager::Matrix, S>
{
    static void write(S* ostr, const ::RoboCompInnerModelManager::Matrix& v)
    {
        ostr->write(v.cols);
        ostr->write(v.rows);
        ostr->write(v.data);
    }
};

template<typename S>
struct StreamReader< ::RoboCompInnerModelManager::Matrix, S>
{
    static void read(S* istr, ::RoboCompInnerModelManager::Matrix& v)
    {
        istr->read(v.cols);
        istr->read(v.rows);
        istr->read(v.data);
    }
};

}
/// \endcond

namespace RoboCompInnerModelManager
{

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_addAttribute.
 * Create a wrapper instance by calling ::RoboCompInnerModelManager::newCallback_InnerModelManager_addAttribute.
 */
template<class T>
class CallbackNC_InnerModelManager_addAttribute : public Callback_InnerModelManager_addAttribute_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_InnerModelManager_addAttribute(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InnerModelManagerPrx proxy = InnerModelManagerPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_addAttribute(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_addAttribute.
 */
template<class T> Callback_InnerModelManager_addAttributePtr
newCallback_InnerModelManager_addAttribute(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InnerModelManager_addAttribute<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_addAttribute.
 */
template<class T> Callback_InnerModelManager_addAttributePtr
newCallback_InnerModelManager_addAttribute(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InnerModelManager_addAttribute<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_addAttribute.
 * Create a wrapper instance by calling ::RoboCompInnerModelManager::newCallback_InnerModelManager_addAttribute.
 */
template<class T, typename CT>
class Callback_InnerModelManager_addAttribute : public Callback_InnerModelManager_addAttribute_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_InnerModelManager_addAttribute(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InnerModelManagerPrx proxy = InnerModelManagerPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_addAttribute(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_addAttribute.
 */
template<class T, typename CT> Callback_InnerModelManager_addAttributePtr
newCallback_InnerModelManager_addAttribute(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InnerModelManager_addAttribute<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_addAttribute.
 */
template<class T, typename CT> Callback_InnerModelManager_addAttributePtr
newCallback_InnerModelManager_addAttribute(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InnerModelManager_addAttribute<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_addJoint.
 * Create a wrapper instance by calling ::RoboCompInnerModelManager::newCallback_InnerModelManager_addJoint.
 */
template<class T>
class CallbackNC_InnerModelManager_addJoint : public Callback_InnerModelManager_addJoint_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_InnerModelManager_addJoint(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InnerModelManagerPrx proxy = InnerModelManagerPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_addJoint(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_addJoint.
 */
template<class T> Callback_InnerModelManager_addJointPtr
newCallback_InnerModelManager_addJoint(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InnerModelManager_addJoint<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_addJoint.
 */
template<class T> Callback_InnerModelManager_addJointPtr
newCallback_InnerModelManager_addJoint(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InnerModelManager_addJoint<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_addJoint.
 * Create a wrapper instance by calling ::RoboCompInnerModelManager::newCallback_InnerModelManager_addJoint.
 */
template<class T, typename CT>
class Callback_InnerModelManager_addJoint : public Callback_InnerModelManager_addJoint_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_InnerModelManager_addJoint(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InnerModelManagerPrx proxy = InnerModelManagerPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_addJoint(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_addJoint.
 */
template<class T, typename CT> Callback_InnerModelManager_addJointPtr
newCallback_InnerModelManager_addJoint(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InnerModelManager_addJoint<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_addJoint.
 */
template<class T, typename CT> Callback_InnerModelManager_addJointPtr
newCallback_InnerModelManager_addJoint(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InnerModelManager_addJoint<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_addMesh.
 * Create a wrapper instance by calling ::RoboCompInnerModelManager::newCallback_InnerModelManager_addMesh.
 */
template<class T>
class CallbackNC_InnerModelManager_addMesh : public Callback_InnerModelManager_addMesh_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_InnerModelManager_addMesh(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InnerModelManagerPrx proxy = InnerModelManagerPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_addMesh(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_addMesh.
 */
template<class T> Callback_InnerModelManager_addMeshPtr
newCallback_InnerModelManager_addMesh(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InnerModelManager_addMesh<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_addMesh.
 */
template<class T> Callback_InnerModelManager_addMeshPtr
newCallback_InnerModelManager_addMesh(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InnerModelManager_addMesh<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_addMesh.
 * Create a wrapper instance by calling ::RoboCompInnerModelManager::newCallback_InnerModelManager_addMesh.
 */
template<class T, typename CT>
class Callback_InnerModelManager_addMesh : public Callback_InnerModelManager_addMesh_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_InnerModelManager_addMesh(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InnerModelManagerPrx proxy = InnerModelManagerPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_addMesh(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_addMesh.
 */
template<class T, typename CT> Callback_InnerModelManager_addMeshPtr
newCallback_InnerModelManager_addMesh(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InnerModelManager_addMesh<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_addMesh.
 */
template<class T, typename CT> Callback_InnerModelManager_addMeshPtr
newCallback_InnerModelManager_addMesh(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InnerModelManager_addMesh<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_addPlane.
 * Create a wrapper instance by calling ::RoboCompInnerModelManager::newCallback_InnerModelManager_addPlane.
 */
template<class T>
class CallbackNC_InnerModelManager_addPlane : public Callback_InnerModelManager_addPlane_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_InnerModelManager_addPlane(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InnerModelManagerPrx proxy = InnerModelManagerPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_addPlane(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_addPlane.
 */
template<class T> Callback_InnerModelManager_addPlanePtr
newCallback_InnerModelManager_addPlane(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InnerModelManager_addPlane<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_addPlane.
 */
template<class T> Callback_InnerModelManager_addPlanePtr
newCallback_InnerModelManager_addPlane(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InnerModelManager_addPlane<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_addPlane.
 * Create a wrapper instance by calling ::RoboCompInnerModelManager::newCallback_InnerModelManager_addPlane.
 */
template<class T, typename CT>
class Callback_InnerModelManager_addPlane : public Callback_InnerModelManager_addPlane_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_InnerModelManager_addPlane(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InnerModelManagerPrx proxy = InnerModelManagerPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_addPlane(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_addPlane.
 */
template<class T, typename CT> Callback_InnerModelManager_addPlanePtr
newCallback_InnerModelManager_addPlane(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InnerModelManager_addPlane<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_addPlane.
 */
template<class T, typename CT> Callback_InnerModelManager_addPlanePtr
newCallback_InnerModelManager_addPlane(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InnerModelManager_addPlane<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_addTransform.
 * Create a wrapper instance by calling ::RoboCompInnerModelManager::newCallback_InnerModelManager_addTransform.
 */
template<class T>
class CallbackNC_InnerModelManager_addTransform : public Callback_InnerModelManager_addTransform_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_InnerModelManager_addTransform(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InnerModelManagerPrx proxy = InnerModelManagerPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_addTransform(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_addTransform.
 */
template<class T> Callback_InnerModelManager_addTransformPtr
newCallback_InnerModelManager_addTransform(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InnerModelManager_addTransform<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_addTransform.
 */
template<class T> Callback_InnerModelManager_addTransformPtr
newCallback_InnerModelManager_addTransform(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InnerModelManager_addTransform<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_addTransform.
 * Create a wrapper instance by calling ::RoboCompInnerModelManager::newCallback_InnerModelManager_addTransform.
 */
template<class T, typename CT>
class Callback_InnerModelManager_addTransform : public Callback_InnerModelManager_addTransform_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_InnerModelManager_addTransform(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InnerModelManagerPrx proxy = InnerModelManagerPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_addTransform(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_addTransform.
 */
template<class T, typename CT> Callback_InnerModelManager_addTransformPtr
newCallback_InnerModelManager_addTransform(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InnerModelManager_addTransform<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_addTransform.
 */
template<class T, typename CT> Callback_InnerModelManager_addTransformPtr
newCallback_InnerModelManager_addTransform(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InnerModelManager_addTransform<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_collide.
 * Create a wrapper instance by calling ::RoboCompInnerModelManager::newCallback_InnerModelManager_collide.
 */
template<class T>
class CallbackNC_InnerModelManager_collide : public Callback_InnerModelManager_collide_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_InnerModelManager_collide(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InnerModelManagerPrx proxy = InnerModelManagerPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_collide(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_collide.
 */
template<class T> Callback_InnerModelManager_collidePtr
newCallback_InnerModelManager_collide(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InnerModelManager_collide<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_collide.
 */
template<class T> Callback_InnerModelManager_collidePtr
newCallback_InnerModelManager_collide(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InnerModelManager_collide<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_collide.
 * Create a wrapper instance by calling ::RoboCompInnerModelManager::newCallback_InnerModelManager_collide.
 */
template<class T, typename CT>
class Callback_InnerModelManager_collide : public Callback_InnerModelManager_collide_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_InnerModelManager_collide(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InnerModelManagerPrx proxy = InnerModelManagerPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_collide(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_collide.
 */
template<class T, typename CT> Callback_InnerModelManager_collidePtr
newCallback_InnerModelManager_collide(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InnerModelManager_collide<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_collide.
 */
template<class T, typename CT> Callback_InnerModelManager_collidePtr
newCallback_InnerModelManager_collide(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InnerModelManager_collide<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_getAllNodeInformation.
 * Create a wrapper instance by calling ::RoboCompInnerModelManager::newCallback_InnerModelManager_getAllNodeInformation.
 */
template<class T>
class CallbackNC_InnerModelManager_getAllNodeInformation : public Callback_InnerModelManager_getAllNodeInformation_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const NodeInformationSequence&);

    CallbackNC_InnerModelManager_getAllNodeInformation(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InnerModelManagerPrx proxy = InnerModelManagerPrx::uncheckedCast(result->getProxy());
        NodeInformationSequence iceP_nodesInfo;
        try
        {
            proxy->end_getAllNodeInformation(iceP_nodesInfo, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(iceP_nodesInfo);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_getAllNodeInformation.
 */
template<class T> Callback_InnerModelManager_getAllNodeInformationPtr
newCallback_InnerModelManager_getAllNodeInformation(const IceUtil::Handle<T>& instance, void (T::*cb)(const NodeInformationSequence&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InnerModelManager_getAllNodeInformation<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_getAllNodeInformation.
 */
template<class T> Callback_InnerModelManager_getAllNodeInformationPtr
newCallback_InnerModelManager_getAllNodeInformation(T* instance, void (T::*cb)(const NodeInformationSequence&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InnerModelManager_getAllNodeInformation<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_getAllNodeInformation.
 * Create a wrapper instance by calling ::RoboCompInnerModelManager::newCallback_InnerModelManager_getAllNodeInformation.
 */
template<class T, typename CT>
class Callback_InnerModelManager_getAllNodeInformation : public Callback_InnerModelManager_getAllNodeInformation_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const NodeInformationSequence&, const CT&);

    Callback_InnerModelManager_getAllNodeInformation(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InnerModelManagerPrx proxy = InnerModelManagerPrx::uncheckedCast(result->getProxy());
        NodeInformationSequence iceP_nodesInfo;
        try
        {
            proxy->end_getAllNodeInformation(iceP_nodesInfo, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(iceP_nodesInfo, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_getAllNodeInformation.
 */
template<class T, typename CT> Callback_InnerModelManager_getAllNodeInformationPtr
newCallback_InnerModelManager_getAllNodeInformation(const IceUtil::Handle<T>& instance, void (T::*cb)(const NodeInformationSequence&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InnerModelManager_getAllNodeInformation<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_getAllNodeInformation.
 */
template<class T, typename CT> Callback_InnerModelManager_getAllNodeInformationPtr
newCallback_InnerModelManager_getAllNodeInformation(T* instance, void (T::*cb)(const NodeInformationSequence&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InnerModelManager_getAllNodeInformation<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_getAttribute.
 * Create a wrapper instance by calling ::RoboCompInnerModelManager::newCallback_InnerModelManager_getAttribute.
 */
template<class T>
class CallbackNC_InnerModelManager_getAttribute : public Callback_InnerModelManager_getAttribute_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool, const ::std::string&, const ::std::string&);

    CallbackNC_InnerModelManager_getAttribute(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InnerModelManagerPrx proxy = InnerModelManagerPrx::uncheckedCast(result->getProxy());
        ::std::string iceP_type;
        ::std::string iceP_value;
        bool ret;
        try
        {
            ret = proxy->end_getAttribute(iceP_type, iceP_value, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_type, iceP_value);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_getAttribute.
 */
template<class T> Callback_InnerModelManager_getAttributePtr
newCallback_InnerModelManager_getAttribute(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const ::std::string&, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InnerModelManager_getAttribute<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_getAttribute.
 */
template<class T> Callback_InnerModelManager_getAttributePtr
newCallback_InnerModelManager_getAttribute(T* instance, void (T::*cb)(bool, const ::std::string&, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InnerModelManager_getAttribute<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_getAttribute.
 * Create a wrapper instance by calling ::RoboCompInnerModelManager::newCallback_InnerModelManager_getAttribute.
 */
template<class T, typename CT>
class Callback_InnerModelManager_getAttribute : public Callback_InnerModelManager_getAttribute_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const ::std::string&, const ::std::string&, const CT&);

    Callback_InnerModelManager_getAttribute(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InnerModelManagerPrx proxy = InnerModelManagerPrx::uncheckedCast(result->getProxy());
        ::std::string iceP_type;
        ::std::string iceP_value;
        bool ret;
        try
        {
            ret = proxy->end_getAttribute(iceP_type, iceP_value, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_type, iceP_value, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_getAttribute.
 */
template<class T, typename CT> Callback_InnerModelManager_getAttributePtr
newCallback_InnerModelManager_getAttribute(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const ::std::string&, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InnerModelManager_getAttribute<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_getAttribute.
 */
template<class T, typename CT> Callback_InnerModelManager_getAttributePtr
newCallback_InnerModelManager_getAttribute(T* instance, void (T::*cb)(bool, const ::std::string&, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InnerModelManager_getAttribute<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_getPose.
 * Create a wrapper instance by calling ::RoboCompInnerModelManager::newCallback_InnerModelManager_getPose.
 */
template<class T>
class CallbackNC_InnerModelManager_getPose : public Callback_InnerModelManager_getPose_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool, const Pose3D&);

    CallbackNC_InnerModelManager_getPose(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InnerModelManagerPrx proxy = InnerModelManagerPrx::uncheckedCast(result->getProxy());
        Pose3D iceP_pose;
        bool ret;
        try
        {
            ret = proxy->end_getPose(iceP_pose, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_pose);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_getPose.
 */
template<class T> Callback_InnerModelManager_getPosePtr
newCallback_InnerModelManager_getPose(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const Pose3D&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InnerModelManager_getPose<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_getPose.
 */
template<class T> Callback_InnerModelManager_getPosePtr
newCallback_InnerModelManager_getPose(T* instance, void (T::*cb)(bool, const Pose3D&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InnerModelManager_getPose<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_getPose.
 * Create a wrapper instance by calling ::RoboCompInnerModelManager::newCallback_InnerModelManager_getPose.
 */
template<class T, typename CT>
class Callback_InnerModelManager_getPose : public Callback_InnerModelManager_getPose_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const Pose3D&, const CT&);

    Callback_InnerModelManager_getPose(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InnerModelManagerPrx proxy = InnerModelManagerPrx::uncheckedCast(result->getProxy());
        Pose3D iceP_pose;
        bool ret;
        try
        {
            ret = proxy->end_getPose(iceP_pose, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_pose, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_getPose.
 */
template<class T, typename CT> Callback_InnerModelManager_getPosePtr
newCallback_InnerModelManager_getPose(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const Pose3D&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InnerModelManager_getPose<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_getPose.
 */
template<class T, typename CT> Callback_InnerModelManager_getPosePtr
newCallback_InnerModelManager_getPose(T* instance, void (T::*cb)(bool, const Pose3D&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InnerModelManager_getPose<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_getPoseFromParent.
 * Create a wrapper instance by calling ::RoboCompInnerModelManager::newCallback_InnerModelManager_getPoseFromParent.
 */
template<class T>
class CallbackNC_InnerModelManager_getPoseFromParent : public Callback_InnerModelManager_getPoseFromParent_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool, const Pose3D&);

    CallbackNC_InnerModelManager_getPoseFromParent(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InnerModelManagerPrx proxy = InnerModelManagerPrx::uncheckedCast(result->getProxy());
        Pose3D iceP_pose;
        bool ret;
        try
        {
            ret = proxy->end_getPoseFromParent(iceP_pose, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_pose);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_getPoseFromParent.
 */
template<class T> Callback_InnerModelManager_getPoseFromParentPtr
newCallback_InnerModelManager_getPoseFromParent(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const Pose3D&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InnerModelManager_getPoseFromParent<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_getPoseFromParent.
 */
template<class T> Callback_InnerModelManager_getPoseFromParentPtr
newCallback_InnerModelManager_getPoseFromParent(T* instance, void (T::*cb)(bool, const Pose3D&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InnerModelManager_getPoseFromParent<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_getPoseFromParent.
 * Create a wrapper instance by calling ::RoboCompInnerModelManager::newCallback_InnerModelManager_getPoseFromParent.
 */
template<class T, typename CT>
class Callback_InnerModelManager_getPoseFromParent : public Callback_InnerModelManager_getPoseFromParent_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const Pose3D&, const CT&);

    Callback_InnerModelManager_getPoseFromParent(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InnerModelManagerPrx proxy = InnerModelManagerPrx::uncheckedCast(result->getProxy());
        Pose3D iceP_pose;
        bool ret;
        try
        {
            ret = proxy->end_getPoseFromParent(iceP_pose, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_pose, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_getPoseFromParent.
 */
template<class T, typename CT> Callback_InnerModelManager_getPoseFromParentPtr
newCallback_InnerModelManager_getPoseFromParent(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const Pose3D&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InnerModelManager_getPoseFromParent<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_getPoseFromParent.
 */
template<class T, typename CT> Callback_InnerModelManager_getPoseFromParentPtr
newCallback_InnerModelManager_getPoseFromParent(T* instance, void (T::*cb)(bool, const Pose3D&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InnerModelManager_getPoseFromParent<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_getTransformationMatrix.
 * Create a wrapper instance by calling ::RoboCompInnerModelManager::newCallback_InnerModelManager_getTransformationMatrix.
 */
template<class T>
class CallbackNC_InnerModelManager_getTransformationMatrix : public Callback_InnerModelManager_getTransformationMatrix_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const Matrix&);

    CallbackNC_InnerModelManager_getTransformationMatrix(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InnerModelManagerPrx proxy = InnerModelManagerPrx::uncheckedCast(result->getProxy());
        Matrix ret;
        try
        {
            ret = proxy->end_getTransformationMatrix(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_getTransformationMatrix.
 */
template<class T> Callback_InnerModelManager_getTransformationMatrixPtr
newCallback_InnerModelManager_getTransformationMatrix(const IceUtil::Handle<T>& instance, void (T::*cb)(const Matrix&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InnerModelManager_getTransformationMatrix<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_getTransformationMatrix.
 */
template<class T> Callback_InnerModelManager_getTransformationMatrixPtr
newCallback_InnerModelManager_getTransformationMatrix(T* instance, void (T::*cb)(const Matrix&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InnerModelManager_getTransformationMatrix<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_getTransformationMatrix.
 * Create a wrapper instance by calling ::RoboCompInnerModelManager::newCallback_InnerModelManager_getTransformationMatrix.
 */
template<class T, typename CT>
class Callback_InnerModelManager_getTransformationMatrix : public Callback_InnerModelManager_getTransformationMatrix_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const Matrix&, const CT&);

    Callback_InnerModelManager_getTransformationMatrix(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InnerModelManagerPrx proxy = InnerModelManagerPrx::uncheckedCast(result->getProxy());
        Matrix ret;
        try
        {
            ret = proxy->end_getTransformationMatrix(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_getTransformationMatrix.
 */
template<class T, typename CT> Callback_InnerModelManager_getTransformationMatrixPtr
newCallback_InnerModelManager_getTransformationMatrix(const IceUtil::Handle<T>& instance, void (T::*cb)(const Matrix&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InnerModelManager_getTransformationMatrix<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_getTransformationMatrix.
 */
template<class T, typename CT> Callback_InnerModelManager_getTransformationMatrixPtr
newCallback_InnerModelManager_getTransformationMatrix(T* instance, void (T::*cb)(const Matrix&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InnerModelManager_getTransformationMatrix<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_moveNode.
 * Create a wrapper instance by calling ::RoboCompInnerModelManager::newCallback_InnerModelManager_moveNode.
 */
template<class T>
class CallbackNC_InnerModelManager_moveNode : public Callback_InnerModelManager_moveNode_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_InnerModelManager_moveNode(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InnerModelManagerPrx proxy = InnerModelManagerPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_moveNode(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_moveNode.
 */
template<class T> Callback_InnerModelManager_moveNodePtr
newCallback_InnerModelManager_moveNode(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InnerModelManager_moveNode<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_moveNode.
 */
template<class T> Callback_InnerModelManager_moveNodePtr
newCallback_InnerModelManager_moveNode(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InnerModelManager_moveNode<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_moveNode.
 * Create a wrapper instance by calling ::RoboCompInnerModelManager::newCallback_InnerModelManager_moveNode.
 */
template<class T, typename CT>
class Callback_InnerModelManager_moveNode : public Callback_InnerModelManager_moveNode_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_InnerModelManager_moveNode(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InnerModelManagerPrx proxy = InnerModelManagerPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_moveNode(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_moveNode.
 */
template<class T, typename CT> Callback_InnerModelManager_moveNodePtr
newCallback_InnerModelManager_moveNode(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InnerModelManager_moveNode<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_moveNode.
 */
template<class T, typename CT> Callback_InnerModelManager_moveNodePtr
newCallback_InnerModelManager_moveNode(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InnerModelManager_moveNode<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_removeAttribute.
 * Create a wrapper instance by calling ::RoboCompInnerModelManager::newCallback_InnerModelManager_removeAttribute.
 */
template<class T>
class CallbackNC_InnerModelManager_removeAttribute : public Callback_InnerModelManager_removeAttribute_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_InnerModelManager_removeAttribute(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InnerModelManagerPrx proxy = InnerModelManagerPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_removeAttribute(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_removeAttribute.
 */
template<class T> Callback_InnerModelManager_removeAttributePtr
newCallback_InnerModelManager_removeAttribute(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InnerModelManager_removeAttribute<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_removeAttribute.
 */
template<class T> Callback_InnerModelManager_removeAttributePtr
newCallback_InnerModelManager_removeAttribute(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InnerModelManager_removeAttribute<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_removeAttribute.
 * Create a wrapper instance by calling ::RoboCompInnerModelManager::newCallback_InnerModelManager_removeAttribute.
 */
template<class T, typename CT>
class Callback_InnerModelManager_removeAttribute : public Callback_InnerModelManager_removeAttribute_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_InnerModelManager_removeAttribute(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InnerModelManagerPrx proxy = InnerModelManagerPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_removeAttribute(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_removeAttribute.
 */
template<class T, typename CT> Callback_InnerModelManager_removeAttributePtr
newCallback_InnerModelManager_removeAttribute(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InnerModelManager_removeAttribute<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_removeAttribute.
 */
template<class T, typename CT> Callback_InnerModelManager_removeAttributePtr
newCallback_InnerModelManager_removeAttribute(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InnerModelManager_removeAttribute<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_removeNode.
 * Create a wrapper instance by calling ::RoboCompInnerModelManager::newCallback_InnerModelManager_removeNode.
 */
template<class T>
class CallbackNC_InnerModelManager_removeNode : public Callback_InnerModelManager_removeNode_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_InnerModelManager_removeNode(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InnerModelManagerPrx proxy = InnerModelManagerPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_removeNode(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_removeNode.
 */
template<class T> Callback_InnerModelManager_removeNodePtr
newCallback_InnerModelManager_removeNode(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InnerModelManager_removeNode<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_removeNode.
 */
template<class T> Callback_InnerModelManager_removeNodePtr
newCallback_InnerModelManager_removeNode(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InnerModelManager_removeNode<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_removeNode.
 * Create a wrapper instance by calling ::RoboCompInnerModelManager::newCallback_InnerModelManager_removeNode.
 */
template<class T, typename CT>
class Callback_InnerModelManager_removeNode : public Callback_InnerModelManager_removeNode_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_InnerModelManager_removeNode(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InnerModelManagerPrx proxy = InnerModelManagerPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_removeNode(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_removeNode.
 */
template<class T, typename CT> Callback_InnerModelManager_removeNodePtr
newCallback_InnerModelManager_removeNode(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InnerModelManager_removeNode<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_removeNode.
 */
template<class T, typename CT> Callback_InnerModelManager_removeNodePtr
newCallback_InnerModelManager_removeNode(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InnerModelManager_removeNode<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_setAttribute.
 * Create a wrapper instance by calling ::RoboCompInnerModelManager::newCallback_InnerModelManager_setAttribute.
 */
template<class T>
class CallbackNC_InnerModelManager_setAttribute : public Callback_InnerModelManager_setAttribute_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_InnerModelManager_setAttribute(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InnerModelManagerPrx proxy = InnerModelManagerPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_setAttribute(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_setAttribute.
 */
template<class T> Callback_InnerModelManager_setAttributePtr
newCallback_InnerModelManager_setAttribute(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InnerModelManager_setAttribute<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_setAttribute.
 */
template<class T> Callback_InnerModelManager_setAttributePtr
newCallback_InnerModelManager_setAttribute(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InnerModelManager_setAttribute<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_setAttribute.
 * Create a wrapper instance by calling ::RoboCompInnerModelManager::newCallback_InnerModelManager_setAttribute.
 */
template<class T, typename CT>
class Callback_InnerModelManager_setAttribute : public Callback_InnerModelManager_setAttribute_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_InnerModelManager_setAttribute(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InnerModelManagerPrx proxy = InnerModelManagerPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_setAttribute(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_setAttribute.
 */
template<class T, typename CT> Callback_InnerModelManager_setAttributePtr
newCallback_InnerModelManager_setAttribute(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InnerModelManager_setAttribute<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_setAttribute.
 */
template<class T, typename CT> Callback_InnerModelManager_setAttributePtr
newCallback_InnerModelManager_setAttribute(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InnerModelManager_setAttribute<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_setPlane.
 * Create a wrapper instance by calling ::RoboCompInnerModelManager::newCallback_InnerModelManager_setPlane.
 */
template<class T>
class CallbackNC_InnerModelManager_setPlane : public Callback_InnerModelManager_setPlane_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_InnerModelManager_setPlane(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InnerModelManagerPrx proxy = InnerModelManagerPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_setPlane(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_setPlane.
 */
template<class T> Callback_InnerModelManager_setPlanePtr
newCallback_InnerModelManager_setPlane(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InnerModelManager_setPlane<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_setPlane.
 */
template<class T> Callback_InnerModelManager_setPlanePtr
newCallback_InnerModelManager_setPlane(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InnerModelManager_setPlane<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_setPlane.
 * Create a wrapper instance by calling ::RoboCompInnerModelManager::newCallback_InnerModelManager_setPlane.
 */
template<class T, typename CT>
class Callback_InnerModelManager_setPlane : public Callback_InnerModelManager_setPlane_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_InnerModelManager_setPlane(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InnerModelManagerPrx proxy = InnerModelManagerPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_setPlane(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_setPlane.
 */
template<class T, typename CT> Callback_InnerModelManager_setPlanePtr
newCallback_InnerModelManager_setPlane(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InnerModelManager_setPlane<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_setPlane.
 */
template<class T, typename CT> Callback_InnerModelManager_setPlanePtr
newCallback_InnerModelManager_setPlane(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InnerModelManager_setPlane<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_setPointCloudData.
 * Create a wrapper instance by calling ::RoboCompInnerModelManager::newCallback_InnerModelManager_setPointCloudData.
 */
template<class T>
class CallbackNC_InnerModelManager_setPointCloudData : public Callback_InnerModelManager_setPointCloudData_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_InnerModelManager_setPointCloudData(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_setPointCloudData.
 */
template<class T> Callback_InnerModelManager_setPointCloudDataPtr
newCallback_InnerModelManager_setPointCloudData(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InnerModelManager_setPointCloudData<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_setPointCloudData.
 */
template<class T> Callback_InnerModelManager_setPointCloudDataPtr
newCallback_InnerModelManager_setPointCloudData(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InnerModelManager_setPointCloudData<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_setPointCloudData.
 */
template<class T> Callback_InnerModelManager_setPointCloudDataPtr
newCallback_InnerModelManager_setPointCloudData(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InnerModelManager_setPointCloudData<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_setPointCloudData.
 */
template<class T> Callback_InnerModelManager_setPointCloudDataPtr
newCallback_InnerModelManager_setPointCloudData(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InnerModelManager_setPointCloudData<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_setPointCloudData.
 * Create a wrapper instance by calling ::RoboCompInnerModelManager::newCallback_InnerModelManager_setPointCloudData.
 */
template<class T, typename CT>
class Callback_InnerModelManager_setPointCloudData : public Callback_InnerModelManager_setPointCloudData_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_InnerModelManager_setPointCloudData(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_setPointCloudData.
 */
template<class T, typename CT> Callback_InnerModelManager_setPointCloudDataPtr
newCallback_InnerModelManager_setPointCloudData(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InnerModelManager_setPointCloudData<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_setPointCloudData.
 */
template<class T, typename CT> Callback_InnerModelManager_setPointCloudDataPtr
newCallback_InnerModelManager_setPointCloudData(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InnerModelManager_setPointCloudData<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_setPointCloudData.
 */
template<class T, typename CT> Callback_InnerModelManager_setPointCloudDataPtr
newCallback_InnerModelManager_setPointCloudData(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InnerModelManager_setPointCloudData<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_setPointCloudData.
 */
template<class T, typename CT> Callback_InnerModelManager_setPointCloudDataPtr
newCallback_InnerModelManager_setPointCloudData(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InnerModelManager_setPointCloudData<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_setPose.
 * Create a wrapper instance by calling ::RoboCompInnerModelManager::newCallback_InnerModelManager_setPose.
 */
template<class T>
class CallbackNC_InnerModelManager_setPose : public Callback_InnerModelManager_setPose_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_InnerModelManager_setPose(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InnerModelManagerPrx proxy = InnerModelManagerPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_setPose(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_setPose.
 */
template<class T> Callback_InnerModelManager_setPosePtr
newCallback_InnerModelManager_setPose(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InnerModelManager_setPose<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_setPose.
 */
template<class T> Callback_InnerModelManager_setPosePtr
newCallback_InnerModelManager_setPose(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InnerModelManager_setPose<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_setPose.
 * Create a wrapper instance by calling ::RoboCompInnerModelManager::newCallback_InnerModelManager_setPose.
 */
template<class T, typename CT>
class Callback_InnerModelManager_setPose : public Callback_InnerModelManager_setPose_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_InnerModelManager_setPose(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InnerModelManagerPrx proxy = InnerModelManagerPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_setPose(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_setPose.
 */
template<class T, typename CT> Callback_InnerModelManager_setPosePtr
newCallback_InnerModelManager_setPose(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InnerModelManager_setPose<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_setPose.
 */
template<class T, typename CT> Callback_InnerModelManager_setPosePtr
newCallback_InnerModelManager_setPose(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InnerModelManager_setPose<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_setPoseFromParent.
 * Create a wrapper instance by calling ::RoboCompInnerModelManager::newCallback_InnerModelManager_setPoseFromParent.
 */
template<class T>
class CallbackNC_InnerModelManager_setPoseFromParent : public Callback_InnerModelManager_setPoseFromParent_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_InnerModelManager_setPoseFromParent(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InnerModelManagerPrx proxy = InnerModelManagerPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_setPoseFromParent(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_setPoseFromParent.
 */
template<class T> Callback_InnerModelManager_setPoseFromParentPtr
newCallback_InnerModelManager_setPoseFromParent(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InnerModelManager_setPoseFromParent<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_setPoseFromParent.
 */
template<class T> Callback_InnerModelManager_setPoseFromParentPtr
newCallback_InnerModelManager_setPoseFromParent(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InnerModelManager_setPoseFromParent<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_setPoseFromParent.
 * Create a wrapper instance by calling ::RoboCompInnerModelManager::newCallback_InnerModelManager_setPoseFromParent.
 */
template<class T, typename CT>
class Callback_InnerModelManager_setPoseFromParent : public Callback_InnerModelManager_setPoseFromParent_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_InnerModelManager_setPoseFromParent(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InnerModelManagerPrx proxy = InnerModelManagerPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_setPoseFromParent(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_setPoseFromParent.
 */
template<class T, typename CT> Callback_InnerModelManager_setPoseFromParentPtr
newCallback_InnerModelManager_setPoseFromParent(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InnerModelManager_setPoseFromParent<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_setPoseFromParent.
 */
template<class T, typename CT> Callback_InnerModelManager_setPoseFromParentPtr
newCallback_InnerModelManager_setPoseFromParent(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InnerModelManager_setPoseFromParent<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_setScale.
 * Create a wrapper instance by calling ::RoboCompInnerModelManager::newCallback_InnerModelManager_setScale.
 */
template<class T>
class CallbackNC_InnerModelManager_setScale : public Callback_InnerModelManager_setScale_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_InnerModelManager_setScale(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InnerModelManagerPrx proxy = InnerModelManagerPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_setScale(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_setScale.
 */
template<class T> Callback_InnerModelManager_setScalePtr
newCallback_InnerModelManager_setScale(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InnerModelManager_setScale<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_setScale.
 */
template<class T> Callback_InnerModelManager_setScalePtr
newCallback_InnerModelManager_setScale(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InnerModelManager_setScale<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_setScale.
 * Create a wrapper instance by calling ::RoboCompInnerModelManager::newCallback_InnerModelManager_setScale.
 */
template<class T, typename CT>
class Callback_InnerModelManager_setScale : public Callback_InnerModelManager_setScale_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_InnerModelManager_setScale(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InnerModelManagerPrx proxy = InnerModelManagerPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_setScale(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_setScale.
 */
template<class T, typename CT> Callback_InnerModelManager_setScalePtr
newCallback_InnerModelManager_setScale(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InnerModelManager_setScale<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_setScale.
 */
template<class T, typename CT> Callback_InnerModelManager_setScalePtr
newCallback_InnerModelManager_setScale(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InnerModelManager_setScale<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_transform.
 * Create a wrapper instance by calling ::RoboCompInnerModelManager::newCallback_InnerModelManager_transform.
 */
template<class T>
class CallbackNC_InnerModelManager_transform : public Callback_InnerModelManager_transform_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool, const coord3D&);

    CallbackNC_InnerModelManager_transform(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InnerModelManagerPrx proxy = InnerModelManagerPrx::uncheckedCast(result->getProxy());
        coord3D iceP_coordInBase;
        bool ret;
        try
        {
            ret = proxy->end_transform(iceP_coordInBase, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_coordInBase);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_transform.
 */
template<class T> Callback_InnerModelManager_transformPtr
newCallback_InnerModelManager_transform(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const coord3D&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InnerModelManager_transform<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_transform.
 */
template<class T> Callback_InnerModelManager_transformPtr
newCallback_InnerModelManager_transform(T* instance, void (T::*cb)(bool, const coord3D&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_InnerModelManager_transform<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_transform.
 * Create a wrapper instance by calling ::RoboCompInnerModelManager::newCallback_InnerModelManager_transform.
 */
template<class T, typename CT>
class Callback_InnerModelManager_transform : public Callback_InnerModelManager_transform_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const coord3D&, const CT&);

    Callback_InnerModelManager_transform(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        InnerModelManagerPrx proxy = InnerModelManagerPrx::uncheckedCast(result->getProxy());
        coord3D iceP_coordInBase;
        bool ret;
        try
        {
            ret = proxy->end_transform(iceP_coordInBase, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_coordInBase, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_transform.
 */
template<class T, typename CT> Callback_InnerModelManager_transformPtr
newCallback_InnerModelManager_transform(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const coord3D&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InnerModelManager_transform<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompInnerModelManager::InnerModelManager::begin_transform.
 */
template<class T, typename CT> Callback_InnerModelManager_transformPtr
newCallback_InnerModelManager_transform(T* instance, void (T::*cb)(bool, const coord3D&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_InnerModelManager_transform<T, CT>(instance, cb, excb, sentcb);
}

}

#endif

#include <IceUtil/PopDisableWarnings.h>
#endif
